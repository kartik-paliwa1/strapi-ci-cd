{
  "version": 3,
  "sources": ["../../../../../packages/core/admin/admin/src/hooks/useRBAC.ts", "../../../../../packages/core/admin/admin/src/utils/once.ts", "../../../../../packages/core/admin/admin/src/hooks/usePrev.ts"],
  "sourcesContent": ["import * as React from 'react';\n\nimport isEqual from 'lodash/isEqual';\n\nimport { useAuth, Permission } from '../features/Auth';\nimport { once } from '../utils/once';\nimport { capitalise } from '../utils/strings';\n\nimport { usePrev } from './usePrev';\n\ntype AllowedActions = Record<string, boolean>;\n\n/**\n * @public\n * @description This hooks takes an object or array of permissions (the latter preferred) and\n * runs through them to match against the current user's permissions as well as the RBAC middleware\n * system checking any conditions that may be present. It returns the filtered permissions as the complete\n * object from the API and a set of actions that can be performed. An action is derived from the last part\n * of the permission action e.g. `admin::roles.create` would be `canCreate`. If there's a hyphen in the action\n * this is removed and capitalised e.g `admin::roles.create-draft` would be `canCreateDraft`.\n * @example\n * ```tsx\n * import { Page, useRBAC } from '@strapi/strapi/admin'\n *\n * const MyProtectedPage = () => {\n *  const { allowedActions, isLoading, error, permissions } = useRBAC([{ action: 'admin::roles.create' }])\n *\n *  if(isLoading) {\n *    return <Page.Loading />\n *  }\n *\n *  if(error){\n *    return <Page.Error />\n *  }\n *\n *  if(!allowedActions.canCreate) {\n *    return null\n *  }\n *\n *  return <MyPage permissions={permissions} />\n * }\n * ```\n */\nconst useRBAC = (\n  permissionsToCheck: Record<string, Permission[]> | Permission[] = [],\n  passedPermissions?: Permission[],\n  rawQueryContext?: string\n): {\n  allowedActions: AllowedActions;\n  isLoading: boolean;\n  error?: unknown;\n  permissions: Permission[];\n} => {\n  const isLoadingAuth = useAuth('useRBAC', (state) => state.isLoading);\n  const [isLoading, setIsLoading] = React.useState(true);\n  const [error, setError] = React.useState<unknown>();\n  const [data, setData] = React.useState<Record<string, boolean>>();\n\n  const warnOnce = React.useMemo(() => once(console.warn), []);\n\n  const actualPermissionsToCheck: Permission[] = React.useMemo(() => {\n    if (Array.isArray(permissionsToCheck)) {\n      return permissionsToCheck;\n    } else {\n      warnOnce(\n        'useRBAC: The first argument should be an array of permissions, not an object. This will be deprecated in the future.'\n      );\n\n      return Object.values(permissionsToCheck).flat();\n    }\n  }, [permissionsToCheck, warnOnce]);\n\n  /**\n   * This is the default value we return until the queryResults[i].data\n   * are all resolved with data. This preserves the original behaviour.\n   */\n  const defaultAllowedActions = React.useMemo(() => {\n    return actualPermissionsToCheck.reduce<Record<string, boolean>>((acc, permission) => {\n      return {\n        ...acc,\n        [getActionName(permission)]: false,\n      };\n    }, {});\n  }, [actualPermissionsToCheck]);\n\n  const checkUserHasPermissions = useAuth('useRBAC', (state) => state.checkUserHasPermissions);\n\n  const permssionsChecked = usePrev(actualPermissionsToCheck);\n  const contextChecked = usePrev(rawQueryContext);\n\n  React.useEffect(() => {\n    if (\n      !isEqual(permssionsChecked, actualPermissionsToCheck) ||\n      // TODO: also run this when the query context changes\n      contextChecked !== rawQueryContext\n    ) {\n      setIsLoading(true);\n      setData(undefined);\n      setError(undefined);\n\n      checkUserHasPermissions(actualPermissionsToCheck, passedPermissions, rawQueryContext)\n        .then((res) => {\n          if (res) {\n            setData(\n              res.reduce<Record<string, boolean>>((acc, permission) => {\n                return {\n                  ...acc,\n                  [getActionName(permission)]: true,\n                };\n              }, {})\n            );\n          }\n        })\n        .catch((err) => {\n          setError(err);\n        })\n        .finally(() => {\n          setIsLoading(false);\n        });\n    }\n  }, [\n    actualPermissionsToCheck,\n    checkUserHasPermissions,\n    passedPermissions,\n    permissionsToCheck,\n    permssionsChecked,\n    contextChecked,\n    rawQueryContext,\n  ]);\n\n  /**\n   * This hook originally would not return allowedActions\n   * until all the checks were complete.\n   */\n  const allowedActions = Object.entries({\n    ...defaultAllowedActions,\n    ...data,\n  }).reduce((acc, [name, allowed]) => {\n    acc[`can${capitalise(name)}`] = allowed;\n\n    return acc;\n  }, {} as AllowedActions);\n\n  return {\n    allowedActions,\n    permissions: actualPermissionsToCheck,\n    isLoading: isLoading || isLoadingAuth,\n    error,\n  };\n};\n\nconst getActionName = (permission: Permission): string => {\n  const [action = ''] = permission.action.split('.').slice(-1);\n  return action.split('-').map(capitalise).join('');\n};\n\nexport { useRBAC };\nexport type { AllowedActions };\n", "export const once = <TFunc extends (...args: any) => any>(fn: TFunc) => {\n  const func = fn;\n  let called = false;\n\n  if (typeof func !== 'function') {\n    throw new TypeError(`once requires a function parameter`);\n  }\n\n  return (...args: any) => {\n    if (!called && process.env.NODE_ENV === 'development') {\n      func(...args);\n      called = true;\n    }\n  };\n};\n", "import { useEffect, useRef } from 'react';\n\nexport const usePrev = <T>(value: T): T | undefined => {\n  const ref = useRef<T>();\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n};\n"],
  "mappings": "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",
  "names": ["isEqual"]
}
