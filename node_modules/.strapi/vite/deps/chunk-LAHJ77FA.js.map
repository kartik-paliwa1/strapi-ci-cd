{
  "version": 3,
  "sources": ["../../../../../packages/core/content-manager/admin/src/constants/collections.ts", "../../../../../packages/core/content-manager/admin/src/pages/EditView/utils/data.ts", "../../../../../packages/core/content-manager/admin/src/constants/attributes.ts", "../../../../../packages/core/content-manager/admin/src/services/documents.ts", "../../../../../packages/core/content-manager/admin/src/utils/api.ts", "../../../../../packages/core/content-manager/admin/src/utils/validation.ts", "../../../../../packages/core/content-manager/admin/src/services/init.ts", "../../../../../packages/core/content-manager/admin/src/hooks/useContentTypeSchema.ts", "../../../../../packages/core/content-manager/admin/src/constants/hooks.ts", "../../../../../packages/core/content-manager/admin/src/services/contentTypes.ts", "../../../../../packages/core/content-manager/admin/src/hooks/useDocumentLayout.ts", "../../../../../packages/core/content-manager/admin/src/utils/attributes.ts", "../../../../../packages/core/content-manager/admin/src/hooks/useDocument.ts", "../../../../../packages/core/content-manager/admin/src/pages/EditView/utils/forms.ts", "../../../../../packages/core/content-manager/admin/src/utils/objects.ts"],
  "sourcesContent": ["const SINGLE_TYPES = 'single-types';\nconst COLLECTION_TYPES = 'collection-types';\n\nexport { SINGLE_TYPES, COLLECTION_TYPES };\n", "import { createRulesEngine } from '@strapi/admin/strapi-admin';\nimport { generateNKeysBetween } from 'fractional-indexing';\nimport pipe from 'lodash/fp/pipe';\n\nimport { DOCUMENT_META_FIELDS } from '../../../constants/attributes';\n\nimport type { ComponentsDictionary, Document } from '../../../hooks/useDocument';\nimport type { Schema, UID } from '@strapi/types';\n\n/* -------------------------------------------------------------------------------------------------\n * traverseData\n * -----------------------------------------------------------------------------------------------*/\n\n// Make only attributes required since it's the only one Content History has\ntype PartialSchema = Partial<Schema.Schema> & Pick<Schema.Schema, 'attributes'>;\n\ntype Predicate = <TAttribute extends Schema.Attribute.AnyAttribute>(\n  attribute: TAttribute,\n  value: Schema.Attribute.Value<TAttribute>\n) => boolean;\ntype Transform = <TAttribute extends Schema.Attribute.AnyAttribute>(\n  value: any,\n  attribute: TAttribute\n) => any;\ntype AnyData = Omit<Document, 'id'>;\n\nconst BLOCK_LIST_ATTRIBUTE_KEYS = ['__component', '__temp_key__'];\n\n/**\n * @internal This function is used to traverse the data and transform the values.\n * Given a predicate function, it will transform the value (using the given transform function)\n * if the predicate returns true. If it finds that the attribute is a component or dynamiczone,\n * it will recursively traverse those data structures as well.\n *\n * It is possible to break the ContentManager by using this function incorrectly, for example,\n * if you transform a number into a string but the attribute type is a number, the ContentManager\n * will not be able to save the data and the Form will likely crash because the component it's\n * passing the data too won't succesfully be able to handle the value.\n */\nconst traverseData =\n  (predicate: Predicate, transform: Transform) =>\n  (schema: PartialSchema, components: ComponentsDictionary = {}) =>\n  (data: AnyData = {}) => {\n    const traverse = (datum: AnyData, attributes: Schema.Schema['attributes']) => {\n      return Object.entries(datum).reduce<AnyData>((acc, [key, value]) => {\n        const attribute = attributes[key];\n\n        /**\n         * If the attribute is a block list attribute, we don't want to transform it.\n         * We also don't want to transform null or undefined values.\n         */\n        if (BLOCK_LIST_ATTRIBUTE_KEYS.includes(key) || value === null || value === undefined) {\n          acc[key] = value;\n          return acc;\n        }\n\n        if (attribute.type === 'component') {\n          if (attribute.repeatable) {\n            const componentValue = (\n              predicate(attribute, value) ? transform(value, attribute) : value\n            ) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, true>>;\n            acc[key] = componentValue.map((componentData) =>\n              traverse(componentData, components[attribute.component]?.attributes ?? {})\n            );\n          } else {\n            const componentValue = (\n              predicate(attribute, value) ? transform(value, attribute) : value\n            ) as Schema.Attribute.Value<Schema.Attribute.Component<UID.Component, false>>;\n\n            acc[key] = traverse(componentValue, components[attribute.component]?.attributes ?? {});\n          }\n        } else if (attribute.type === 'dynamiczone') {\n          const dynamicZoneValue = (\n            predicate(attribute, value) ? transform(value, attribute) : value\n          ) as Schema.Attribute.Value<Schema.Attribute.DynamicZone>;\n\n          acc[key] = dynamicZoneValue.map((componentData) =>\n            traverse(componentData, components[componentData.__component]?.attributes ?? {})\n          );\n        } else if (predicate(attribute, value)) {\n          acc[key] = transform(value, attribute);\n        } else {\n          acc[key] = value;\n        }\n\n        return acc;\n      }, {});\n    };\n\n    return traverse(data, schema.attributes);\n  };\n\n/* -------------------------------------------------------------------------------------------------\n * removeProhibitedFields\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal Removes all the fields that are not allowed.\n */\nconst removeProhibitedFields = (prohibitedFields: Schema.Attribute.Kind[]) =>\n  traverseData(\n    (attribute) => prohibitedFields.includes(attribute.type),\n    () => ''\n  );\n\n/* -------------------------------------------------------------------------------------------------\n * prepareRelations\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Sets all relation values to an empty array.\n */\nconst prepareRelations = traverseData(\n  (attribute) => attribute.type === 'relation',\n  () => ({\n    connect: [],\n    disconnect: [],\n  })\n);\n\n/* -------------------------------------------------------------------------------------------------\n * prepareTempKeys\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Adds a `__temp_key__` to each component and dynamiczone item. This gives us\n * a stable identifier regardless of its ids etc. that we can then use for drag and drop.\n */\nconst prepareTempKeys = traverseData(\n  (attribute) =>\n    (attribute.type === 'component' && attribute.repeatable) || attribute.type === 'dynamiczone',\n  (data) => {\n    if (Array.isArray(data) && data.length > 0) {\n      const keys = generateNKeysBetween(undefined, undefined, data.length);\n\n      return data.map((datum, index) => ({\n        ...datum,\n        __temp_key__: keys[index],\n      }));\n    }\n\n    return data;\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * removeFieldsThatDontExistOnSchema\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Fields that don't exist in the schema like createdAt etc. are only on the first level (not nested),\n * as such we don't need to traverse the components to remove them.\n */\nconst removeFieldsThatDontExistOnSchema = (schema: PartialSchema) => (data: AnyData) => {\n  const schemaKeys = Object.keys(schema.attributes);\n  const dataKeys = Object.keys(data);\n\n  const keysToRemove = dataKeys.filter((key) => !schemaKeys.includes(key));\n\n  const revisedData = [...keysToRemove, ...DOCUMENT_META_FIELDS].reduce((acc, key) => {\n    delete acc[key];\n\n    return acc;\n  }, structuredClone(data));\n\n  return revisedData;\n};\n\n/**\n * @internal\n * @description We need to remove null fields from the data-structure because it will pass it\n * to the specific inputs breaking them as most would prefer empty strings or `undefined` if\n * they're controlled / uncontrolled.\n */\nconst removeNullValues = (data: AnyData) => {\n  return Object.entries(data).reduce<AnyData>((acc, [key, value]) => {\n    if (value === null) {\n      return acc;\n    }\n\n    acc[key] = value;\n\n    return acc;\n  }, {});\n};\n\n/* -------------------------------------------------------------------------------------------------\n * transformDocuments\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description Takes a document data structure (this could be from the API or a default form structure)\n * and applies consistent data transformations to it. This is also used when we add new components to the\n * form to ensure the data is correctly prepared from their default state e.g. relations are set to an empty array.\n */\nconst transformDocument =\n  (schema: PartialSchema, components: ComponentsDictionary = {}) =>\n  (document: AnyData) => {\n    const transformations = pipe(\n      removeFieldsThatDontExistOnSchema(schema),\n      removeProhibitedFields(['password'])(schema, components),\n      removeNullValues,\n      prepareRelations(schema, components),\n      prepareTempKeys(schema, components)\n    );\n\n    return transformations(document);\n  };\n\ntype HandleOptions = {\n  schema?: Schema.ContentType | Schema.Component;\n  initialValues?: AnyData;\n  components?: Record<string, Schema.Component>;\n};\n\ntype RemovedFieldPath = string;\n\n/**\n * @internal\n * @description Finds the initial value for a component or dynamic zone item (based on its __temp_key__ and not its index).\n * @param initialValue - The initial values object.\n * @param item - The item to find the initial value for.\n * @returns The initial value for the item.\n */\nconst getItemInitialValue = (initialValue: AnyData, item: AnyData) => {\n  if (initialValue && Array.isArray(initialValue)) {\n    const matchingInitialItem = initialValue.find(\n      (initialItem) => initialItem.__temp_key__ === item.__temp_key__\n    );\n    if (matchingInitialItem) {\n      return matchingInitialItem;\n    }\n  }\n  return {};\n};\n\n/**\n * Removes values from the data object if their corresponding attribute has a\n * visibility condition that evaluates to false.\n *\n * @param {object} schema - The content type schema (with attributes).\n * @param {object} data - The data object to filter based on visibility.\n * @returns {object} A new data object with only visible fields retained.\n */\nconst handleInvisibleAttributes = (\n  data: AnyData,\n  { schema, initialValues = {}, components = {} }: HandleOptions,\n  path: string[] = [],\n  removedAttributes: RemovedFieldPath[] = []\n): {\n  data: AnyData;\n  removedAttributes: RemovedFieldPath[];\n} => {\n  if (!schema?.attributes) return { data, removedAttributes };\n\n  const rulesEngine = createRulesEngine();\n  const result: AnyData = {};\n\n  for (const [attrName, attrDef] of Object.entries(schema.attributes)) {\n    const fullPath = [...path, attrName].join('.');\n    const condition = attrDef?.conditions?.visible;\n    const isVisible = condition ? rulesEngine.evaluate(condition, { ...data, ...result }) : true;\n\n    if (!isVisible) {\n      removedAttributes.push(fullPath);\n      continue;\n    }\n\n    const userProvided = Object.prototype.hasOwnProperty.call(data, attrName);\n    const currentValue = userProvided ? data[attrName] : undefined;\n    const initialValue = initialValues?.[attrName];\n\n    // ðŸ”¹ Handle components\n    if (attrDef.type === 'component') {\n      const compSchema = components[attrDef.component];\n      const value = currentValue === undefined ? initialValue : currentValue;\n\n      if (!value) {\n        result[attrName] = attrDef.repeatable ? [] : null;\n        continue;\n      }\n\n      if (attrDef.repeatable && Array.isArray(value)) {\n        result[attrName] = value.map((item) => {\n          const componentInitialValue = getItemInitialValue(initialValue, item);\n\n          return handleInvisibleAttributes(\n            item,\n            {\n              schema: compSchema,\n              initialValues: componentInitialValue,\n              components,\n            },\n            [...path, `${attrName}[${item.__temp_key__}]`],\n            removedAttributes\n          ).data;\n        });\n      } else {\n        result[attrName] = handleInvisibleAttributes(\n          value,\n          {\n            schema: compSchema,\n            initialValues: initialValue ?? {},\n            components,\n          },\n          [...path, attrName],\n          removedAttributes\n        ).data;\n      }\n\n      continue;\n    }\n\n    // ðŸ”¸ Handle dynamic zones\n    if (attrDef.type === 'dynamiczone') {\n      if (!Array.isArray(currentValue)) {\n        result[attrName] = [];\n        continue;\n      }\n\n      result[attrName] = currentValue.map((dzItem) => {\n        const compUID = dzItem?.__component;\n        const compSchema = components[compUID];\n\n        const componentInitialValue = getItemInitialValue(initialValue, dzItem);\n\n        const cleaned = handleInvisibleAttributes(\n          dzItem,\n          {\n            schema: compSchema,\n            initialValues: componentInitialValue,\n            components,\n          },\n          [...path, `${attrName}[${dzItem.__temp_key__}]`],\n          removedAttributes\n        ).data;\n\n        // For newly created components, we want to be sure that the id is undefined (in case of reordering items)\n        const processedItem =\n          dzItem.id === undefined || dzItem.id === null\n            ? { __component: compUID, ...cleaned, id: undefined }\n            : { __component: compUID, ...cleaned };\n\n        return processedItem;\n      });\n\n      continue;\n    }\n\n    // ðŸŸ¡ Handle scalar/primitive\n    if (currentValue !== undefined) {\n      result[attrName] = currentValue;\n    } else if (initialValue !== undefined) {\n      result[attrName] = initialValue;\n    } else {\n      if (attrName === 'id' || attrName === 'documentId') {\n        // If the attribute is 'id', we don't want to set it to null, as it should not be removed.\n        continue;\n      }\n      result[attrName] = null;\n    }\n  }\n\n  return {\n    data: result,\n    removedAttributes,\n  };\n};\n\nexport {\n  removeProhibitedFields,\n  prepareRelations,\n  prepareTempKeys,\n  removeFieldsThatDontExistOnSchema,\n  transformDocument,\n  handleInvisibleAttributes,\n};\nexport type { AnyData };\n", "const ID = 'id';\n\nconst CREATED_BY_ATTRIBUTE_NAME = 'createdBy';\nconst UPDATED_BY_ATTRIBUTE_NAME = 'updatedBy';\n\nconst CREATOR_FIELDS = [CREATED_BY_ATTRIBUTE_NAME, UPDATED_BY_ATTRIBUTE_NAME];\n\nconst PUBLISHED_BY_ATTRIBUTE_NAME = 'publishedBy';\nconst CREATED_AT_ATTRIBUTE_NAME = 'createdAt';\nconst UPDATED_AT_ATTRIBUTE_NAME = 'updatedAt';\nconst PUBLISHED_AT_ATTRIBUTE_NAME = 'publishedAt';\n\nconst DOCUMENT_META_FIELDS = [\n  ID,\n  ...CREATOR_FIELDS,\n  PUBLISHED_BY_ATTRIBUTE_NAME,\n  CREATED_AT_ATTRIBUTE_NAME,\n  UPDATED_AT_ATTRIBUTE_NAME,\n  PUBLISHED_AT_ATTRIBUTE_NAME,\n];\n\n/**\n * List of attribute types that cannot be used as the main field.\n * Not sure the name could be any clearer.\n */\nconst ATTRIBUTE_TYPES_THAT_CANNOT_BE_MAIN_FIELD = [\n  'dynamiczone',\n  'json',\n  'text',\n  'relation',\n  'component',\n  'boolean',\n  'media',\n  'password',\n  'richtext',\n  'timestamp',\n  'blocks',\n];\n\nexport {\n  ATTRIBUTE_TYPES_THAT_CANNOT_BE_MAIN_FIELD,\n  CREATED_AT_ATTRIBUTE_NAME,\n  UPDATED_AT_ATTRIBUTE_NAME,\n  PUBLISHED_AT_ATTRIBUTE_NAME,\n  CREATED_BY_ATTRIBUTE_NAME,\n  UPDATED_BY_ATTRIBUTE_NAME,\n  PUBLISHED_BY_ATTRIBUTE_NAME,\n  CREATOR_FIELDS,\n  DOCUMENT_META_FIELDS,\n};\n", "/**\n * Related to fetching the actual content of a collection type or single type.\n */\nimport { stringify } from 'qs';\n\nimport { SINGLE_TYPES } from '../constants/collections';\n\nimport { contentManagerApi } from './api';\n\nimport type {\n  Clone,\n  Create,\n  Delete,\n  Find,\n  FindOne,\n  BulkDelete,\n  BulkPublish,\n  BulkUnpublish,\n  Discard,\n  CountDraftRelations,\n  CountManyEntriesDraftRelations,\n  Publish,\n  Unpublish,\n  Update,\n} from '../../../shared/contracts/collection-types';\n\nconst documentApi = contentManagerApi.injectEndpoints({\n  overrideExisting: true,\n  endpoints: (builder) => ({\n    autoCloneDocument: builder.mutation<\n      Clone.Response,\n      Clone.Params & {\n        params?: Find.Request['query'] & Clone.Request['query'];\n      }\n    >({\n      query: ({ model, sourceId, params }) => ({\n        url: `/content-manager/collection-types/${model}/auto-clone/${sourceId}`,\n        method: 'POST',\n        config: {\n          params,\n        },\n      }),\n      invalidatesTags: (_result, error, { model }) => {\n        if (error) {\n          return [];\n        }\n\n        return [\n          { type: 'Document', id: `${model}_LIST` },\n          'RecentDocumentList',\n          'CountDocuments',\n          'UpcomingReleasesList',\n        ];\n      },\n    }),\n    cloneDocument: builder.mutation<\n      Clone.Response,\n      Clone.Params & {\n        data: Clone.Request['body'];\n        params?: Clone.Request['query'];\n      }\n    >({\n      query: ({ model, sourceId, data, params }) => ({\n        url: `/content-manager/collection-types/${model}/clone/${sourceId}`,\n        method: 'POST',\n        data,\n        config: {\n          params,\n        },\n      }),\n      invalidatesTags: (_result, _error, { model }) => [\n        { type: 'Document', id: `${model}_LIST` },\n        { type: 'UidAvailability', id: model },\n        'RecentDocumentList',\n        'CountDocuments',\n        'UpcomingReleasesList',\n      ],\n    }),\n    /**\n     * Creates a new collection-type document. This should ONLY be used for collection-types.\n     * single-types should always be using `updateDocument` since they always exist.\n     */\n    createDocument: builder.mutation<\n      Create.Response,\n      Create.Params & {\n        data: Create.Request['body'];\n        params?: Create.Request['query'];\n      }\n    >({\n      query: ({ model, data, params }) => ({\n        url: `/content-manager/collection-types/${model}`,\n        method: 'POST',\n        data,\n        config: {\n          params,\n        },\n      }),\n      invalidatesTags: (result, _error, { model }) => [\n        { type: 'Document', id: `${model}_LIST` },\n        'Relations',\n        { type: 'UidAvailability', id: model },\n        'RecentDocumentList',\n        'CountDocuments',\n        'UpcomingReleasesList',\n      ],\n      transformResponse: (response: Create.Response, meta, arg): Create.Response => {\n        /**\n         * TODO v6\n         * Adapt plugin:users-permissions.user to return the same response\n         * shape as all other requests. The error is returned as expected.\n         */\n        if (!('data' in response) && arg.model === 'plugin::users-permissions.user') {\n          return {\n            data: response,\n            meta: {\n              availableStatus: [],\n              availableLocales: [],\n            },\n          };\n        }\n\n        return response;\n      },\n    }),\n    deleteDocument: builder.mutation<\n      Delete.Response,\n      Pick<Delete.Params, 'model'> &\n        Pick<Partial<Delete.Params>, 'documentId'> & {\n          collectionType: string;\n          params?: Find.Request['query'];\n        }\n    >({\n      query: ({ collectionType, model, documentId, params }) => ({\n        url: `/content-manager/${collectionType}/${model}${\n          collectionType !== SINGLE_TYPES && documentId ? `/${documentId}` : ''\n        }`,\n        method: 'DELETE',\n        config: {\n          params,\n        },\n      }),\n      invalidatesTags: (_result, _error, { collectionType, model }) => [\n        { type: 'Document', id: collectionType !== SINGLE_TYPES ? `${model}_LIST` : model },\n        'RecentDocumentList',\n        'CountDocuments',\n        'UpcomingReleasesList',\n      ],\n    }),\n    deleteManyDocuments: builder.mutation<\n      BulkDelete.Response,\n      BulkDelete.Params & BulkDelete.Request['body'] & { params?: Find.Request['query'] }\n    >({\n      query: ({ model, params, ...body }) => ({\n        url: `/content-manager/collection-types/${model}/actions/bulkDelete`,\n        method: 'POST',\n        data: body,\n        config: {\n          params,\n        },\n      }),\n      invalidatesTags: (_res, _error, { model }) => [\n        { type: 'Document', id: `${model}_LIST` },\n        'RecentDocumentList',\n        'CountDocuments',\n        'UpcomingReleasesList',\n      ],\n    }),\n    discardDocument: builder.mutation<\n      Discard.Response,\n      Pick<Discard.Params, 'model'> &\n        Partial<Pick<Discard.Params, 'documentId'>> & {\n          collectionType: string;\n          params?: Find.Request['query'] & {\n            [key: string]: any;\n          };\n        }\n    >({\n      query: ({ collectionType, model, documentId, params }) => ({\n        url: documentId\n          ? `/content-manager/${collectionType}/${model}/${documentId}/actions/discard`\n          : `/content-manager/${collectionType}/${model}/actions/discard`,\n        method: 'POST',\n        config: {\n          params,\n        },\n      }),\n      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {\n        return [\n          {\n            type: 'Document',\n            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model,\n          },\n          { type: 'Document', id: `${model}_LIST` },\n          'Relations',\n          { type: 'UidAvailability', id: model },\n          'RecentDocumentList',\n          'CountDocuments',\n          'UpcomingReleasesList',\n        ];\n      },\n    }),\n    /**\n     * Gets all documents of a collection type or single type.\n     * By passing different params you can get different results e.g. only published documents or 'es' documents.\n     */\n    getAllDocuments: builder.query<\n      Find.Response,\n      Find.Params & {\n        params?: Find.Request['query'] & {\n          [key: string]: any;\n        };\n      }\n    >({\n      query: ({ model, params }) => ({\n        url: `/content-manager/collection-types/${model}`,\n        method: 'GET',\n        config: {\n          params: stringify(params, { encode: true }),\n        },\n      }),\n      providesTags: (result, _error, arg) => {\n        return [\n          { type: 'Document', id: `ALL_LIST` },\n          { type: 'Document', id: `${arg.model}_LIST` },\n          ...(result?.results.map(({ documentId }) => ({\n            type: 'Document' as const,\n            id: `${arg.model}_${documentId}`,\n          })) ?? []),\n        ];\n      },\n    }),\n    getDraftRelationCount: builder.query<\n      CountDraftRelations.Response,\n      {\n        collectionType: string;\n        model: string;\n        /**\n         * You don't pass the documentId if the document is a single-type\n         */\n        documentId?: string;\n        params?: CountDraftRelations.Request['query'];\n      }\n    >({\n      query: ({ collectionType, model, documentId, params }) => ({\n        url: documentId\n          ? `/content-manager/${collectionType}/${model}/${documentId}/actions/countDraftRelations`\n          : `/content-manager/${collectionType}/${model}/actions/countDraftRelations`,\n        method: 'GET',\n        config: {\n          params,\n        },\n      }),\n    }),\n    getDocument: builder.query<\n      FindOne.Response,\n      Pick<FindOne.Params, 'model'> &\n        Partial<Pick<FindOne.Params, 'documentId'>> & {\n          collectionType: string;\n          params?: FindOne.Request['query'];\n        }\n    >({\n      // @ts-expect-error â€“ TODO: fix ts error where data unknown doesn't work with response via an assertion?\n      queryFn: async (\n        { collectionType, model, documentId, params },\n        _api,\n        _extraOpts,\n        baseQuery\n      ) => {\n        const res = await baseQuery({\n          url: `/content-manager/${collectionType}/${model}${documentId ? `/${documentId}` : ''}`,\n          method: 'GET',\n          config: {\n            params,\n          },\n        });\n\n        /**\n         * To stop the query from locking itself in multiple retries, we intercept the error here and manage correctly.\n         * This is because single-types don't have a list view and fetching them with the route `/single-types/:model`\n         * never returns a list, just a single document but this won't exist if you've not made one before.\n         */\n        if (res.error && res.error.name === 'NotFoundError' && collectionType === SINGLE_TYPES) {\n          return { data: { document: undefined }, error: undefined };\n        }\n\n        return res;\n      },\n      providesTags: (result, _error, { collectionType, model, documentId }) => {\n        return [\n          // we prefer the result's id because we don't fetch single-types with an ID.\n          {\n            type: 'Document',\n            id:\n              collectionType !== SINGLE_TYPES\n                ? `${model}_${result && 'documentId' in result ? result.documentId : documentId}`\n                : model,\n          },\n          // Make it easy to invalidate all individual documents queries for a model\n          {\n            type: 'Document',\n            id: `${model}_ALL_ITEMS`,\n          },\n        ];\n      },\n    }),\n    getManyDraftRelationCount: builder.query<\n      CountManyEntriesDraftRelations.Response['data'],\n      CountManyEntriesDraftRelations.Request['query'] & {\n        model: string;\n      }\n    >({\n      query: ({ model, ...params }) => ({\n        url: `/content-manager/collection-types/${model}/actions/countManyEntriesDraftRelations`,\n        method: 'GET',\n        config: {\n          params,\n        },\n      }),\n      transformResponse: (response: CountManyEntriesDraftRelations.Response) => response.data,\n    }),\n    /**\n     * This endpoint will either create or update documents at the same time as publishing.\n     */\n    publishDocument: builder.mutation<\n      Publish.Response,\n      Pick<Publish.Params, 'model'> &\n        Partial<Pick<Publish.Params, 'documentId'>> & {\n          collectionType: string;\n          data: Publish.Request['body'];\n          params?: Publish.Request['query'];\n        }\n    >({\n      query: ({ collectionType, model, documentId, params, data }) => ({\n        url: documentId\n          ? `/content-manager/${collectionType}/${model}/${documentId}/actions/publish`\n          : `/content-manager/${collectionType}/${model}/actions/publish`,\n        method: 'POST',\n        data,\n        config: {\n          params,\n        },\n      }),\n      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {\n        return [\n          {\n            type: 'Document',\n            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model,\n          },\n          { type: 'Document', id: `${model}_LIST` },\n          'Relations',\n          'RecentDocumentList',\n          'CountDocuments',\n          'UpcomingReleasesList',\n        ];\n      },\n    }),\n    publishManyDocuments: builder.mutation<\n      BulkPublish.Response,\n      BulkPublish.Params & BulkPublish.Request['body'] & { params?: BulkPublish.Request['query'] }\n    >({\n      query: ({ model, params, ...body }) => ({\n        url: `/content-manager/collection-types/${model}/actions/bulkPublish`,\n        method: 'POST',\n        data: body,\n        config: {\n          params,\n        },\n      }),\n      invalidatesTags: (_res, _error, { model, documentIds }) => {\n        return [\n          ...documentIds.map((id) => ({ type: 'Document' as const, id: `${model}_${id}` })),\n          'RecentDocumentList',\n          'CountDocuments',\n          'UpcomingReleasesList',\n        ];\n      },\n    }),\n    updateDocument: builder.mutation<\n      Update.Response,\n      Pick<Update.Params, 'model'> &\n        Partial<Pick<Update.Params, 'documentId'>> & {\n          collectionType: string;\n          data: Update.Request['body'];\n          params?: Update.Request['query'];\n        }\n    >({\n      query: ({ collectionType, model, documentId, data, params }) => ({\n        url: `/content-manager/${collectionType}/${model}${documentId ? `/${documentId}` : ''}`,\n        method: 'PUT',\n        data,\n        config: {\n          params,\n        },\n      }),\n      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {\n        return [\n          {\n            type: 'Document',\n            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model,\n          },\n          'Relations',\n          { type: 'UidAvailability', id: model },\n          'RecentDocumentList',\n          'CountDocuments',\n          'UpcomingReleasesList',\n        ];\n      },\n      async onQueryStarted({ data, ...patch }, { dispatch, queryFulfilled }) {\n        // Optimistically update the cache with the new data\n        const patchResult = dispatch(\n          documentApi.util.updateQueryData('getDocument', patch, (draft) => {\n            Object.assign(draft.data, data);\n          })\n        );\n        try {\n          await queryFulfilled;\n        } catch {\n          // Rollback the optimistic update if there's an error\n          patchResult.undo();\n        }\n      },\n      transformResponse: (response: Update.Response, meta, arg): Update.Response => {\n        /**\n         * TODO v6\n         * Adapt plugin:users-permissions.user to return the same response\n         * shape as all other requests. The error is returned as expected.\n         */\n        if (!('data' in response) && arg.model === 'plugin::users-permissions.user') {\n          return {\n            data: response,\n            meta: {\n              availableStatus: [],\n              availableLocales: [],\n            },\n          };\n        }\n\n        return response;\n      },\n    }),\n    unpublishDocument: builder.mutation<\n      Unpublish.Response,\n      Pick<Unpublish.Params, 'model'> &\n        Partial<Pick<Unpublish.Params, 'documentId'>> & {\n          collectionType: string;\n          params?: Unpublish.Request['query'];\n          data: Unpublish.Request['body'];\n        }\n    >({\n      query: ({ collectionType, model, documentId, params, data }) => ({\n        url: documentId\n          ? `/content-manager/${collectionType}/${model}/${documentId}/actions/unpublish`\n          : `/content-manager/${collectionType}/${model}/actions/unpublish`,\n        method: 'POST',\n        data,\n        config: {\n          params,\n        },\n      }),\n      invalidatesTags: (_result, _error, { collectionType, model, documentId }) => {\n        return [\n          {\n            type: 'Document',\n            id: collectionType !== SINGLE_TYPES ? `${model}_${documentId}` : model,\n          },\n          'RecentDocumentList',\n          'CountDocuments',\n          'UpcomingReleasesList',\n        ];\n      },\n    }),\n    unpublishManyDocuments: builder.mutation<\n      BulkUnpublish.Response,\n      Pick<BulkUnpublish.Params, 'model'> &\n        BulkUnpublish.Request['body'] & {\n          params?: BulkUnpublish.Request['query'];\n        }\n    >({\n      query: ({ model, params, ...body }) => ({\n        url: `/content-manager/collection-types/${model}/actions/bulkUnpublish`,\n        method: 'POST',\n        data: body,\n        config: {\n          params,\n        },\n      }),\n      invalidatesTags: (_res, _error, { model, documentIds }) => [\n        ...documentIds.map((id) => ({ type: 'Document' as const, id: `${model}_${id}` })),\n        'RecentDocumentList',\n        'CountDocuments',\n        'UpcomingReleasesList',\n      ],\n    }),\n  }),\n});\n\nconst {\n  useAutoCloneDocumentMutation,\n  useCloneDocumentMutation,\n  useCreateDocumentMutation,\n  useDeleteDocumentMutation,\n  useDeleteManyDocumentsMutation,\n  useDiscardDocumentMutation,\n  useGetAllDocumentsQuery,\n  useLazyGetDocumentQuery,\n  useGetDocumentQuery,\n  useLazyGetDraftRelationCountQuery,\n  useGetManyDraftRelationCountQuery,\n  usePublishDocumentMutation,\n  usePublishManyDocumentsMutation,\n  useUpdateDocumentMutation,\n  useUnpublishDocumentMutation,\n  useUnpublishManyDocumentsMutation,\n} = documentApi;\n\nexport {\n  useAutoCloneDocumentMutation,\n  useCloneDocumentMutation,\n  useCreateDocumentMutation,\n  useDeleteDocumentMutation,\n  useDeleteManyDocumentsMutation,\n  useDiscardDocumentMutation,\n  useGetAllDocumentsQuery,\n  useLazyGetDocumentQuery,\n  useGetDocumentQuery,\n  useLazyGetDraftRelationCountQuery as useGetDraftRelationCountQuery,\n  useGetManyDraftRelationCountQuery,\n  usePublishDocumentMutation,\n  usePublishManyDocumentsMutation,\n  useUpdateDocumentMutation,\n  useUnpublishDocumentMutation,\n  useUnpublishManyDocumentsMutation,\n};\n", "import { SerializedError } from '@reduxjs/toolkit';\nimport { ApiError, type UnknownApiError } from '@strapi/admin/strapi-admin';\n\ninterface Query {\n  plugins?: Record<string, unknown>;\n  _q?: string;\n  [key: string]: any;\n}\n\n/**\n * This type extracts the plugin options from the query\n * and appends them to the root of the query\n */\ntype TransformedQuery<TQuery extends Query> = Omit<TQuery, 'plugins'> & {\n  [key: string]: string;\n};\n\n/**\n * @description\n * Creates a valid query params object for get requests\n * ie. plugins[i18n][locale]=en becomes locale=en\n */\nconst buildValidParams = <TQuery extends Query>(query: TQuery): TransformedQuery<TQuery> => {\n  if (!query) return query;\n\n  // Extract pluginOptions from the query, they shouldn't be part of the URL\n  const { plugins: _, ...validQueryParams } = {\n    ...query,\n    ...Object.values(query?.plugins ?? {}).reduce<Record<string, string>>(\n      (acc, current) => Object.assign(acc, current),\n      {}\n    ),\n  };\n\n  return validQueryParams;\n};\n\ntype BaseQueryError = ApiError | UnknownApiError;\n\nconst isBaseQueryError = (error: BaseQueryError | SerializedError): error is BaseQueryError => {\n  return error.name !== undefined;\n};\n\nexport { isBaseQueryError, buildValidParams };\nexport type { BaseQueryError, UnknownApiError };\n", "import { translatedErrors } from '@strapi/admin/strapi-admin';\nimport pipe from 'lodash/fp/pipe';\nimport * as yup from 'yup';\n\nimport { DOCUMENT_META_FIELDS } from '../constants/attributes';\n\nimport type { ComponentsDictionary, Schema } from '../hooks/useDocument';\nimport type { Schema as SchemaUtils } from '@strapi/types';\nimport type { ObjectShape } from 'yup/lib/object';\n\ntype AnySchema =\n  | yup.StringSchema\n  | yup.NumberSchema\n  | yup.BooleanSchema\n  | yup.DateSchema\n  | yup.ArraySchema<any>\n  | yup.ObjectSchema<any>;\n\n/* -------------------------------------------------------------------------------------------------\n * createYupSchema\n * -----------------------------------------------------------------------------------------------*/\n\ninterface ValidationOptions {\n  status: 'draft' | 'published' | null;\n  removedAttributes?: string[];\n}\n\nconst arrayValidator = (attribute: Schema['attributes'][string], options: ValidationOptions) => ({\n  message: translatedErrors.required,\n  test(value: unknown) {\n    if (options.status === 'draft') {\n      return true;\n    }\n\n    if (!attribute.required) {\n      return true;\n    }\n\n    if (!value) {\n      return false;\n    }\n\n    if (Array.isArray(value) && value.length === 0) {\n      return false;\n    }\n\n    return true;\n  },\n});\nconst escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n/**\n * TODO: should we create a Map to store these based on the hash of the schema?\n */\nconst createYupSchema = (\n  attributes: Schema['attributes'] = {},\n  components: ComponentsDictionary = {},\n  options: ValidationOptions = { status: null }\n): yup.ObjectSchema<any> => {\n  const createModelSchema = (\n    attributes: Schema['attributes'],\n    removedAttributes: string[] = []\n  ): yup.ObjectSchema<any> =>\n    yup\n      .object()\n      .shape(\n        Object.entries(attributes).reduce<ObjectShape>((acc, [name, attribute]) => {\n          const getNestedPathsForAttribute = (removed: string[], attrName: string): string[] => {\n            const prefix = `${attrName}.`;\n            const bracketRegex = new RegExp(`^${escapeRegex(attrName)}\\\\[\\\\d+\\\\]\\\\.`);\n\n            return removed\n              .filter((p) => p.startsWith(prefix) || bracketRegex.test(p))\n              .map((p) =>\n                p.startsWith(prefix) ? p.slice(prefix.length) : p.replace(bracketRegex, '')\n              );\n          };\n\n          if (DOCUMENT_META_FIELDS.includes(name)) {\n            return acc;\n          }\n\n          if (removedAttributes?.includes(name)) {\n            // If the attribute is not visible, we don't want to validate it\n            return acc;\n          }\n\n          const nestedRemoved = getNestedPathsForAttribute(removedAttributes, name);\n\n          /**\n           * These validations won't apply to every attribute\n           * and that's okay, in that case we just return the\n           * schema as it was passed.\n           */\n          const validations = [\n            addNullableValidation,\n            addRequiredValidation,\n            addMinLengthValidation,\n            addMaxLengthValidation,\n            addMinValidation,\n            addMaxValidation,\n            addRegexValidation,\n          ].map((fn) => fn(attribute, options));\n\n          const transformSchema = pipe(...validations);\n\n          switch (attribute.type) {\n            case 'component': {\n              const { attributes } = components[attribute.component];\n\n              if (attribute.repeatable) {\n                return {\n                  ...acc,\n                  [name]: transformSchema(\n                    yup.array().of(createModelSchema(attributes, nestedRemoved).nullable(false))\n                  ).test(arrayValidator(attribute, options)),\n                };\n              } else {\n                return {\n                  ...acc,\n                  [name]: transformSchema(createModelSchema(attributes, nestedRemoved).nullable()),\n                };\n              }\n            }\n            case 'dynamiczone':\n              return {\n                ...acc,\n                [name]: transformSchema(\n                  yup.array().of(\n                    yup.lazy(\n                      (\n                        data: SchemaUtils.Attribute.Value<SchemaUtils.Attribute.DynamicZone>[number]\n                      ) => {\n                        const attributes = components?.[data?.__component]?.attributes;\n\n                        const validation = yup\n                          .object()\n                          .shape({\n                            __component: yup.string().required().oneOf(Object.keys(components)),\n                          })\n                          .nullable(false);\n                        if (!attributes) {\n                          return validation;\n                        }\n\n                        return validation.concat(createModelSchema(attributes, nestedRemoved));\n                      }\n                    ) as unknown as yup.ObjectSchema<any>\n                  )\n                ).test(arrayValidator(attribute, options)),\n              };\n            case 'relation':\n              return {\n                ...acc,\n                [name]: transformSchema(\n                  yup.lazy((value) => {\n                    if (!value) {\n                      return yup.mixed().nullable(true);\n                    } else if (Array.isArray(value)) {\n                      // If a relation value is an array, we expect\n                      // an array of objects with {id} properties, representing the related entities.\n                      return yup.array().of(\n                        yup.object().shape({\n                          id: yup.number().required(),\n                        })\n                      );\n                    } else if (typeof value === 'object') {\n                      // A realtion value can also be an object. Some API\n                      // repsonses return the number of entities in the relation\n                      // as { count: x }\n                      return yup.object();\n                    } else {\n                      return yup\n                        .mixed()\n                        .test(\n                          'type-error',\n                          'Relation values must be either null, an array of objects with {id} or an object.',\n                          () => false\n                        );\n                    }\n                  })\n                ),\n              };\n            default:\n              return {\n                ...acc,\n                [name]: transformSchema(createAttributeSchema(attribute)),\n              };\n          }\n        }, {})\n      )\n      /**\n       * TODO: investigate why an undefined object fails a check of `nullable`.\n       */\n      .default(null);\n\n  return createModelSchema(attributes, options.removedAttributes);\n};\n\nconst createAttributeSchema = (\n  attribute: Exclude<\n    SchemaUtils.Attribute.AnyAttribute,\n    { type: 'dynamiczone' } | { type: 'component' } | { type: 'relation' }\n  >\n) => {\n  switch (attribute.type) {\n    case 'biginteger':\n      return yup.string().matches(/^-?\\d*$/);\n    case 'boolean':\n      return yup.boolean();\n    case 'blocks':\n      return yup.mixed().test('isBlocks', translatedErrors.json, (value) => {\n        if (!value || Array.isArray(value)) {\n          return true;\n        } else {\n          return false;\n        }\n      });\n    case 'decimal':\n    case 'float':\n    case 'integer':\n      return yup.number();\n    case 'email':\n      return yup.string().email(translatedErrors.email);\n    case 'enumeration':\n      return yup.string().oneOf([...attribute.enum, null]);\n    case 'json':\n      return yup.mixed().test('isJSON', translatedErrors.json, (value) => {\n        /**\n         * We don't want to validate the JSON field if it's empty.\n         */\n        if (!value || (typeof value === 'string' && value.length === 0)) {\n          return true;\n        }\n\n        // If the value was created via content API and wasn't changed, then it's still an object\n        if (typeof value === 'object') {\n          try {\n            JSON.stringify(value);\n            return true;\n          } catch (err) {\n            return false;\n          }\n        }\n\n        try {\n          JSON.parse(value);\n\n          return true;\n        } catch (err) {\n          return false;\n        }\n      });\n    case 'password':\n      return yup.string().nullable();\n    case 'richtext':\n    case 'string':\n    case 'text':\n      return yup.string();\n    case 'uid':\n      return yup\n        .string()\n        .matches(attribute.regex ? new RegExp(attribute.regex) : /^[A-Za-z0-9-_.~]*$/);\n    default:\n      /**\n       * This allows any value.\n       */\n      return yup.mixed();\n  }\n};\n\n// Helper function to return schema.nullable() if it exists, otherwise return schema\nconst nullableSchema = <TSchema extends AnySchema>(schema: TSchema) => {\n  return schema?.nullable\n    ? schema.nullable()\n    : // In some cases '.nullable' will not be available on the schema.\n      // e.g. when the schema has been built using yup.lazy (e.g. for relations).\n      // In these cases we should just return the schema as it is.\n      schema;\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Validators\n * -----------------------------------------------------------------------------------------------*/\n/**\n * Our validator functions can be preped with the\n * attribute and then have the schema piped through them.\n */\ntype ValidationFn = (\n  attribute: Schema['attributes'][string],\n  options: ValidationOptions\n) => <TSchema extends AnySchema>(schema: TSchema) => TSchema;\n\nconst addNullableValidation: ValidationFn = () => (schema) => {\n  return nullableSchema(schema);\n};\n\nconst addRequiredValidation: ValidationFn = (attribute, options) => (schema) => {\n  if (options.status === 'draft' || !attribute.required || attribute.type === 'password') {\n    return schema;\n  }\n\n  if (attribute.required && 'required' in schema) {\n    return schema.required(translatedErrors.required);\n  }\n\n  return schema;\n};\n\nconst addMinLengthValidation: ValidationFn =\n  (attribute, options) =>\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\n    // Skip minLength validation for draft\n    if (options.status === 'draft') {\n      return schema;\n    }\n\n    if (\n      'minLength' in attribute &&\n      attribute.minLength &&\n      Number.isInteger(attribute.minLength) &&\n      'min' in schema\n    ) {\n      return schema.min(attribute.minLength, {\n        ...translatedErrors.minLength,\n        values: {\n          min: attribute.minLength,\n        },\n      }) as TSchema;\n    }\n\n    return schema;\n  };\n\nconst addMaxLengthValidation: ValidationFn =\n  (attribute) =>\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\n    if (\n      'maxLength' in attribute &&\n      attribute.maxLength &&\n      Number.isInteger(attribute.maxLength) &&\n      'max' in schema\n    ) {\n      return schema.max(attribute.maxLength, {\n        ...translatedErrors.maxLength,\n        values: {\n          max: attribute.maxLength,\n        },\n      }) as TSchema;\n    }\n\n    return schema;\n  };\n\nconst addMinValidation: ValidationFn =\n  (attribute, options) =>\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\n    // do not validate min for draft\n    if (options.status === 'draft') {\n      return schema;\n    }\n\n    if ('min' in attribute && 'min' in schema) {\n      const min = toInteger(attribute.min);\n\n      if (min) {\n        return schema.min(min, {\n          ...translatedErrors.min,\n          values: {\n            min,\n          },\n        }) as TSchema;\n      }\n    }\n\n    return schema;\n  };\n\nconst addMaxValidation: ValidationFn =\n  (attribute) =>\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\n    if ('max' in attribute) {\n      const max = toInteger(attribute.max);\n\n      if ('max' in schema && max) {\n        return schema.max(max, {\n          ...translatedErrors.max,\n          values: {\n            max,\n          },\n        }) as TSchema;\n      }\n    }\n\n    return schema;\n  };\n\nconst toInteger = (val?: string | number): number | undefined => {\n  if (typeof val === 'number' || val === undefined) {\n    return val;\n  } else {\n    const num = Number(val);\n    return isNaN(num) ? undefined : num;\n  }\n};\n\nconst addRegexValidation: ValidationFn =\n  (attribute) =>\n  <TSchema extends AnySchema>(schema: TSchema): TSchema => {\n    if ('regex' in attribute && attribute.regex && 'matches' in schema) {\n      return schema.matches(new RegExp(attribute.regex), {\n        message: {\n          id: translatedErrors.regex.id,\n          defaultMessage: 'The value does not match the defined pattern.',\n        },\n\n        excludeEmptyString: !attribute.required,\n      }) as TSchema;\n    }\n\n    return schema;\n  };\n\nexport { createYupSchema };\n", "import { contentManagerApi } from './api';\n\nimport type { GetInitData } from '../../../shared/contracts/init';\n\nconst initApi = contentManagerApi.injectEndpoints({\n  endpoints: (builder) => ({\n    getInitialData: builder.query<GetInitData.Response['data'], void>({\n      query: () => '/content-manager/init',\n      transformResponse: (response: GetInitData.Response) => response.data,\n      providesTags: ['InitialData'],\n    }),\n  }),\n});\n\nconst { useGetInitialDataQuery } = initApi;\n\nexport { useGetInitialDataQuery };\n", "import * as React from 'react';\n\nimport { useNotification, useAPIErrorHandler } from '@strapi/admin/strapi-admin';\n\nimport { useGetInitialDataQuery } from '../services/init';\n\nimport type { Component } from '../../../shared/contracts/components';\nimport type { ContentType } from '../../../shared/contracts/content-types';\nimport type { Schema } from '@strapi/types';\n\n/* -------------------------------------------------------------------------------------------------\n * useContentTypeSchema\n * -----------------------------------------------------------------------------------------------*/\ntype ComponentsDictionary = Record<string, Component>;\n\n/**\n * @internal\n * @description Given a model UID, return the schema and the schemas\n * of the associated components within said model's schema. A wrapper\n * implementation around the `useGetInitialDataQuery` with a unique\n * `selectFromResult` function to memoize the calculation.\n *\n * If no model is provided, the hook will return all the schemas.\n */\nconst useContentTypeSchema = (model?: string) => {\n  const { toggleNotification } = useNotification();\n  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();\n\n  const { data, error, isLoading, isFetching } = useGetInitialDataQuery(undefined);\n\n  const { components, contentType, contentTypes } = React.useMemo(() => {\n    const contentType = data?.contentTypes.find((ct) => ct.uid === model);\n\n    const componentsByKey = data?.components.reduce<ComponentsDictionary>((acc, component) => {\n      acc[component.uid] = component;\n\n      return acc;\n    }, {});\n\n    const components = extractContentTypeComponents(contentType?.attributes, componentsByKey);\n\n    return {\n      components: Object.keys(components).length === 0 ? undefined : components,\n      contentType,\n      contentTypes: data?.contentTypes ?? [],\n    };\n  }, [model, data]);\n\n  React.useEffect(() => {\n    if (error) {\n      toggleNotification({\n        type: 'danger',\n        message: formatAPIError(error),\n      });\n    }\n  }, [toggleNotification, error, formatAPIError]);\n\n  return {\n    // This must be memoized to avoid inifiinite re-renders where the empty object is different everytime.\n    components: React.useMemo(() => components ?? {}, [components]),\n    schema: contentType,\n    schemas: contentTypes,\n    isLoading: isLoading || isFetching,\n  };\n};\n\n/* -------------------------------------------------------------------------------------------------\n * extractContentTypeComponents\n * -----------------------------------------------------------------------------------------------*/\n/**\n * @internal\n * @description Extracts the components used in a content type's attributes recursively.\n */\nconst extractContentTypeComponents = (\n  attributes: ContentType['attributes'] = {},\n  allComponents: ComponentsDictionary = {}\n): ComponentsDictionary => {\n  const getComponents = (attributes: Schema.Attribute.AnyAttribute[]) => {\n    return attributes.reduce<string[]>((acc, attribute) => {\n      /**\n       * If the attribute is a component or dynamiczone, we need to recursively\n       * extract the component UIDs from its attributes.\n       */\n      if (attribute.type === 'component') {\n        const componentAttributes = Object.values(\n          allComponents[attribute.component]?.attributes ?? {}\n        );\n\n        acc.push(attribute.component, ...getComponents(componentAttributes));\n      } else if (attribute.type === 'dynamiczone') {\n        acc.push(\n          ...attribute.components,\n          /**\n           * Dynamic zones have an array of components, so we flatMap over them\n           * performing the same search as above.\n           */\n          ...attribute.components.flatMap((componentUid) => {\n            const componentAttributes = Object.values(\n              allComponents[componentUid]?.attributes ?? {}\n            );\n\n            return getComponents(componentAttributes);\n          })\n        );\n      }\n\n      return acc;\n    }, []);\n  };\n\n  const componentUids = getComponents(Object.values(attributes));\n\n  const uniqueComponentUids = [...new Set(componentUids)];\n\n  const componentsByKey = uniqueComponentUids.reduce<ComponentsDictionary>((acc, uid) => {\n    acc[uid] = allComponents[uid];\n\n    return acc;\n  }, {});\n\n  return componentsByKey;\n};\n\nexport { useContentTypeSchema, extractContentTypeComponents };\nexport type { ComponentsDictionary };\n", "export const HOOKS = {\n  /**\n   * Hook that allows to mutate the displayed headers of the list view table\n   * @constant\n   * @type {string}\n   */\n  INJECT_COLUMN_IN_TABLE: 'Admin/CM/pages/ListView/inject-column-in-table',\n\n  /**\n   * Hook that allows to mutate the CM's collection types links pre-set filters\n   * @constant\n   * @type {string}\n   */\n  MUTATE_COLLECTION_TYPES_LINKS: 'Admin/CM/pages/App/mutate-collection-types-links',\n\n  /**\n   * Hook that allows to mutate the CM's edit view layout\n   * @constant\n   * @type {string}\n   */\n  MUTATE_EDIT_VIEW_LAYOUT: 'Admin/CM/pages/EditView/mutate-edit-view-layout',\n\n  /**\n   * Hook that allows to mutate the CM's single types links pre-set filters\n   * @constant\n   * @type {string}\n   */\n  MUTATE_SINGLE_TYPES_LINKS: 'Admin/CM/pages/App/mutate-single-types-links',\n};\n", "import {\n  FindContentTypeConfiguration,\n  UpdateContentTypeConfiguration,\n  FindContentTypesSettings,\n} from '../../../shared/contracts/content-types';\n\nimport { contentManagerApi } from './api';\n\nconst contentTypesApi = contentManagerApi.injectEndpoints({\n  endpoints: (builder) => ({\n    getContentTypeConfiguration: builder.query<\n      FindContentTypeConfiguration.Response['data'],\n      string\n    >({\n      query: (uid) => ({\n        url: `/content-manager/content-types/${uid}/configuration`,\n        method: 'GET',\n      }),\n      transformResponse: (response: FindContentTypeConfiguration.Response) => response.data,\n      providesTags: (_result, _error, uid) => [\n        { type: 'ContentTypesConfiguration', id: uid },\n        { type: 'ContentTypeSettings', id: 'LIST' },\n      ],\n    }),\n    getAllContentTypeSettings: builder.query<FindContentTypesSettings.Response['data'], void>({\n      query: () => '/content-manager/content-types-settings',\n      transformResponse: (response: FindContentTypesSettings.Response) => response.data,\n      providesTags: [{ type: 'ContentTypeSettings', id: 'LIST' }],\n    }),\n    updateContentTypeConfiguration: builder.mutation<\n      UpdateContentTypeConfiguration.Response['data'],\n      UpdateContentTypeConfiguration.Request['body'] & {\n        uid: string;\n      }\n    >({\n      query: ({ uid, ...body }) => ({\n        url: `/content-manager/content-types/${uid}/configuration`,\n        method: 'PUT',\n        data: body,\n      }),\n      transformResponse: (response: UpdateContentTypeConfiguration.Response) => response.data,\n      invalidatesTags: (_result, _error, { uid }) => [\n        { type: 'ContentTypesConfiguration', id: uid },\n        { type: 'ContentTypeSettings', id: 'LIST' },\n        // Is this necessary?\n        { type: 'InitialData' },\n      ],\n    }),\n  }),\n});\n\nconst {\n  useGetContentTypeConfigurationQuery,\n  useGetAllContentTypeSettingsQuery,\n  useUpdateContentTypeConfigurationMutation,\n} = contentTypesApi;\n\nexport {\n  useGetContentTypeConfigurationQuery,\n  useGetAllContentTypeSettingsQuery,\n  useUpdateContentTypeConfigurationMutation,\n};\n", "import * as React from 'react';\n\nimport { SerializedError } from '@reduxjs/toolkit';\nimport {\n  useNotification,\n  useStrapiApp,\n  useAPIErrorHandler,\n  useQueryParams,\n} from '@strapi/admin/strapi-admin';\n\nimport { HOOKS } from '../constants/hooks';\nimport { useGetContentTypeConfigurationQuery } from '../services/contentTypes';\nimport { BaseQueryError } from '../utils/api';\nimport { getMainField } from '../utils/attributes';\n\nimport { useContentTypeSchema } from './useContentTypeSchema';\nimport {\n  type ComponentsDictionary,\n  type Document,\n  type Schema,\n  useDoc,\n  useDocument,\n} from './useDocument';\n\nimport type { ComponentConfiguration } from '../../../shared/contracts/components';\nimport type {\n  Metadatas,\n  FindContentTypeConfiguration,\n  Settings,\n} from '../../../shared/contracts/content-types';\nimport type { Filters, InputProps, Table } from '@strapi/admin/strapi-admin';\nimport type { Schema as SchemaUtils } from '@strapi/types';\n\ntype LayoutOptions = Schema['options'] & Schema['pluginOptions'] & object;\n\ninterface LayoutSettings extends Settings {\n  displayName?: string;\n  icon?: never;\n}\n\ninterface ListFieldLayout\n  extends Table.Header<Document, ListFieldLayout>,\n    Pick<Filters.Filter, 'mainField'> {\n  attribute: SchemaUtils.Attribute.AnyAttribute | { type: 'custom' };\n}\n\ninterface ListLayout {\n  layout: ListFieldLayout[];\n  components?: never;\n  metadatas: {\n    [K in keyof Metadatas]: Metadatas[K]['list'];\n  };\n  options: LayoutOptions;\n  settings: LayoutSettings;\n}\ninterface EditFieldSharedProps\n  extends Omit<InputProps, 'hint' | 'label' | 'type'>,\n    Pick<Filters.Filter, 'mainField'> {\n  hint?: string;\n  label: string;\n  size: number;\n  unique?: boolean;\n  visible?: boolean;\n}\n\n/**\n * Map over all the types in Attribute Types and use that to create a union of new types where the attribute type\n * is under the property attribute and the type is under the property type.\n */\ntype EditFieldLayout = {\n  [K in SchemaUtils.Attribute.Kind]: EditFieldSharedProps & {\n    attribute: Extract<SchemaUtils.Attribute.AnyAttribute, { type: K }>;\n    type: K;\n  };\n}[SchemaUtils.Attribute.Kind];\n\ninterface EditLayout {\n  layout: Array<Array<EditFieldLayout[]>>;\n  components: {\n    [uid: string]: {\n      layout: Array<EditFieldLayout[]>;\n      settings: ComponentConfiguration['settings'] & {\n        displayName?: string;\n        icon?: string;\n      };\n    };\n  };\n  metadatas: {\n    [K in keyof Metadatas]: Metadatas[K]['edit'];\n  };\n  options: LayoutOptions;\n  settings: LayoutSettings;\n}\n\ntype UseDocumentLayout = (model: string) => {\n  error?: BaseQueryError | SerializedError;\n  isLoading: boolean;\n  /**\n   * This is the layout for the edit view,\n   */\n  edit: EditLayout;\n  list: ListLayout;\n};\n\n/* -------------------------------------------------------------------------------------------------\n * useDocumentLayout\n * -----------------------------------------------------------------------------------------------*/\n\nconst DEFAULT_SETTINGS = {\n  bulkable: false,\n  filterable: false,\n  searchable: false,\n  pagination: false,\n  defaultSortBy: '',\n  defaultSortOrder: 'asc',\n  mainField: 'id',\n  pageSize: 10,\n};\n\n/**\n * @alpha\n * @description This hook is used to get the layouts for either the edit view or list view of a specific content-type\n * including the layouts for the components used in the content-type. It also runs the mutation hook waterfall so the data\n * is consistent wherever it is used. It's a light wrapper around the `useDocument` hook, but provides the `skip` option a document\n * is not fetched, however, it does fetch the schemas & components if they do not already exist in the cache.\n *\n * If the fetch fails, it will display a notification to the user.\n *\n * @example\n * ```tsx\n * const { model } = useParams<{ model: string }>();\n * const { edit: { schema: layout } } = useDocumentLayout(model);\n *\n * return layout.map(panel => panel.map(row => row.map(field => <Field.Root {...field} />)))\n * ```\n *\n */\nconst useDocumentLayout: UseDocumentLayout = (model) => {\n  const { schema, components } = useDocument({ model, collectionType: '' }, { skip: true });\n  const [{ query }] = useQueryParams();\n  const runHookWaterfall = useStrapiApp('useDocumentLayout', (state) => state.runHookWaterfall);\n  const { toggleNotification } = useNotification();\n  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();\n  const { isLoading: isLoadingSchemas, schemas } = useContentTypeSchema();\n\n  const {\n    data,\n    isLoading: isLoadingConfigs,\n    error,\n    isFetching: isFetchingConfigs,\n  } = useGetContentTypeConfigurationQuery(model);\n\n  const isLoading = isLoadingSchemas || isFetchingConfigs || isLoadingConfigs;\n\n  React.useEffect(() => {\n    if (error) {\n      toggleNotification({\n        type: 'danger',\n        message: formatAPIError(error),\n      });\n    }\n  }, [error, formatAPIError, toggleNotification]);\n\n  const editLayout = React.useMemo(\n    () =>\n      data && !isLoading\n        ? formatEditLayout(data, { schemas, schema, components })\n        : ({\n            layout: [],\n            components: {},\n            metadatas: {},\n            options: {},\n            settings: DEFAULT_SETTINGS,\n          } as EditLayout),\n    [data, isLoading, schemas, schema, components]\n  );\n\n  const listLayout = React.useMemo(() => {\n    return data && !isLoading\n      ? formatListLayout(data, { schemas, schema, components })\n      : ({\n          layout: [],\n          metadatas: {},\n          options: {},\n          settings: DEFAULT_SETTINGS,\n        } as ListLayout);\n  }, [data, isLoading, schemas, schema, components]);\n\n  const { layout: edit } = React.useMemo(\n    () =>\n      runHookWaterfall(HOOKS.MUTATE_EDIT_VIEW_LAYOUT, {\n        layout: editLayout,\n        query,\n      }),\n    [editLayout, query, runHookWaterfall]\n  );\n\n  return {\n    error,\n    isLoading,\n    edit,\n    list: listLayout,\n  } satisfies ReturnType<UseDocumentLayout>;\n};\n\n/* -------------------------------------------------------------------------------------------------\n * useDocLayout\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal this hook uses the internal useDoc hook, as such it shouldn't be used outside of the\n * content-manager because it won't work as intended.\n */\nconst useDocLayout = () => {\n  const { model } = useDoc();\n  return useDocumentLayout(model);\n};\n\n/* -------------------------------------------------------------------------------------------------\n * formatEditLayout\n * -----------------------------------------------------------------------------------------------*/\ntype LayoutData = FindContentTypeConfiguration.Response['data'];\n\n/**\n * @internal\n * @description takes the configuration data, the schema & the components used in the schema and formats the edit view\n * versions of the schema & components. This is then used to render the edit view of the content-type.\n */\nconst formatEditLayout = (\n  data: LayoutData,\n  {\n    schemas,\n    schema,\n    components,\n  }: { schemas: Schema[]; schema?: Schema; components: ComponentsDictionary }\n): EditLayout => {\n  let currentPanelIndex = 0;\n  /**\n   * The fields arranged by the panels, new panels are made for dynamic zones only.\n   */\n  const panelledEditAttributes = convertEditLayoutToFieldLayouts(\n    data.contentType.layouts.edit,\n    schema?.attributes,\n    data.contentType.metadatas,\n    { configurations: data.components, schemas: components },\n    schemas\n  ).reduce<Array<EditFieldLayout[][]>>((panels, row) => {\n    if (row.some((field) => field.type === 'dynamiczone')) {\n      panels.push([row]);\n      currentPanelIndex += 2;\n    } else {\n      if (!panels[currentPanelIndex]) {\n        panels.push([row]);\n      } else {\n        panels[currentPanelIndex].push(row);\n      }\n    }\n\n    return panels;\n  }, []);\n\n  const componentEditAttributes = Object.entries(data.components).reduce<EditLayout['components']>(\n    (acc, [uid, configuration]) => {\n      acc[uid] = {\n        layout: convertEditLayoutToFieldLayouts(\n          configuration.layouts.edit,\n          components[uid].attributes,\n          configuration.metadatas,\n          { configurations: data.components, schemas: components }\n        ),\n        settings: {\n          ...configuration.settings,\n          icon: components[uid].info.icon,\n          displayName: components[uid].info.displayName,\n        },\n      };\n      return acc;\n    },\n    {}\n  );\n\n  const editMetadatas = Object.entries(data.contentType.metadatas).reduce<EditLayout['metadatas']>(\n    (acc, [attribute, metadata]) => {\n      return {\n        ...acc,\n        [attribute]: metadata.edit,\n      };\n    },\n    {}\n  );\n\n  return {\n    layout: panelledEditAttributes,\n    components: componentEditAttributes,\n    metadatas: editMetadatas,\n    settings: {\n      ...data.contentType.settings,\n      displayName: schema?.info.displayName,\n    },\n    options: {\n      ...schema?.options,\n      ...schema?.pluginOptions,\n      ...data.contentType.options,\n    },\n  };\n};\n\n/* -------------------------------------------------------------------------------------------------\n * convertEditLayoutToFieldLayouts\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description takes the edit layout from either a content-type or a component\n * and formats it into a generic object that can be used to correctly render\n * the form fields.\n */\nconst convertEditLayoutToFieldLayouts = (\n  rows: LayoutData['contentType']['layouts']['edit'],\n  attributes: Schema['attributes'] = {},\n  metadatas: Metadatas,\n  components?: {\n    configurations: Record<string, ComponentConfiguration>;\n    schemas: ComponentsDictionary;\n  },\n  schemas: Schema[] = []\n) => {\n  return rows.map((row) =>\n    row\n      .map((field) => {\n        const attribute = attributes[field.name];\n\n        if (!attribute) {\n          return null;\n        }\n\n        const { edit: metadata } = metadatas[field.name];\n\n        const settings: Partial<Settings> =\n          attribute.type === 'component' && components\n            ? components.configurations[attribute.component].settings\n            : {};\n\n        return {\n          attribute,\n          disabled: !metadata.editable,\n          hint: metadata.description,\n          label: metadata.label ?? '',\n          name: field.name,\n          // @ts-expect-error â€“ mainField does exist on the metadata for a relation.\n          mainField: getMainField(attribute, metadata.mainField || settings.mainField, {\n            schemas,\n            components: components?.schemas ?? {},\n          }),\n          placeholder: metadata.placeholder ?? '',\n          required: attribute.required ?? false,\n          size: field.size,\n          unique: 'unique' in attribute ? attribute.unique : false,\n          visible: metadata.visible ?? true,\n          type: attribute.type,\n        };\n      })\n      .filter((field) => field !== null)\n  ) as EditFieldLayout[][];\n};\n\n/* -------------------------------------------------------------------------------------------------\n * formatListLayout\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description takes the complete configuration data, the schema & the components used in the schema and\n * formats a list view layout for the content-type. This is much simpler than the edit view layout as there\n * are less options to consider.\n */\nconst formatListLayout = (\n  data: LayoutData,\n  {\n    schemas,\n    schema,\n    components,\n  }: { schemas: Schema[]; schema?: Schema; components: ComponentsDictionary }\n): ListLayout => {\n  const listMetadatas = Object.entries(data.contentType.metadatas).reduce<ListLayout['metadatas']>(\n    (acc, [attribute, metadata]) => {\n      return {\n        ...acc,\n        [attribute]: metadata.list,\n      };\n    },\n    {}\n  );\n  /**\n   * The fields arranged by the panels, new panels are made for dynamic zones only.\n   */\n  const listAttributes = convertListLayoutToFieldLayouts(\n    data.contentType.layouts.list,\n    schema?.attributes,\n    listMetadatas,\n    { configurations: data.components, schemas: components },\n    schemas\n  );\n\n  return {\n    layout: listAttributes,\n    settings: { ...data.contentType.settings, displayName: schema?.info.displayName },\n    metadatas: listMetadatas,\n    options: {\n      ...schema?.options,\n      ...schema?.pluginOptions,\n      ...data.contentType.options,\n    },\n  };\n};\n\n/* -------------------------------------------------------------------------------------------------\n * convertListLayoutToFieldLayouts\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal\n * @description takes the columns from the list view configuration and formats them into a generic object\n * combinining metadata and attribute data.\n *\n * @note We do use this to reformat the list of strings when updating the displayed headers for the list view.\n */\nconst convertListLayoutToFieldLayouts = (\n  columns: LayoutData['contentType']['layouts']['list'],\n  attributes: Schema['attributes'] = {},\n  metadatas: ListLayout['metadatas'],\n  components?: {\n    configurations: Record<string, ComponentConfiguration>;\n    schemas: ComponentsDictionary;\n  },\n  schemas: Schema[] = []\n) => {\n  return columns\n    .map((name) => {\n      const attribute = attributes[name];\n\n      if (!attribute) {\n        return null;\n      }\n\n      const metadata = metadatas[name];\n\n      const settings: Partial<Settings> =\n        attribute.type === 'component' && components\n          ? components.configurations[attribute.component].settings\n          : {};\n\n      return {\n        attribute,\n        label: metadata.label ?? '',\n        mainField: getMainField(attribute, metadata.mainField || settings.mainField, {\n          schemas,\n          components: components?.schemas ?? {},\n        }),\n        name: name,\n        searchable: metadata.searchable ?? true,\n        sortable: metadata.sortable ?? true,\n      } satisfies ListFieldLayout;\n    })\n    .filter((field) => field !== null) as ListFieldLayout[];\n};\n\nexport {\n  useDocLayout,\n  useDocumentLayout,\n  convertListLayoutToFieldLayouts,\n  convertEditLayoutToFieldLayouts,\n  DEFAULT_SETTINGS,\n};\nexport type { EditLayout, EditFieldLayout, ListLayout, ListFieldLayout, UseDocumentLayout };\n", "import type { ComponentsDictionary, Schema } from '../hooks/useDocument';\nimport type { Schema as SchemaUtils } from '@strapi/types';\n\nconst checkIfAttributeIsDisplayable = (attribute: SchemaUtils.Attribute.AnyAttribute) => {\n  const { type } = attribute;\n\n  if (type === 'relation') {\n    return !attribute.relation.toLowerCase().includes('morph');\n  }\n\n  return !['json', 'dynamiczone', 'richtext', 'password', 'blocks'].includes(type) && !!type;\n};\n\ninterface MainField {\n  name: string;\n  type: SchemaUtils.Attribute.Kind | 'custom';\n}\n\n/**\n * @internal\n * @description given an attribute, content-type schemas & component schemas, find the mainField name & type.\n * If the attribute does not need a `mainField` then we return undefined. If we do not find the type\n * of the field, we assume it's a string #sensible-defaults\n */\nconst getMainField = (\n  attribute: SchemaUtils.Attribute.AnyAttribute,\n  mainFieldName: string | undefined,\n  { schemas, components }: { schemas: Schema[]; components: ComponentsDictionary }\n): MainField | undefined => {\n  if (!mainFieldName) {\n    return undefined;\n  }\n\n  const mainFieldType =\n    attribute.type === 'component'\n      ? components[attribute.component].attributes[mainFieldName].type\n      : // @ts-expect-error â€“ `targetModel` does exist on the attribute for a relation.\n        schemas.find((schema) => schema.uid === attribute.targetModel)?.attributes[mainFieldName]\n          .type;\n\n  return {\n    name: mainFieldName,\n    type: mainFieldType ?? 'string',\n  };\n};\n\nexport { checkIfAttributeIsDisplayable, getMainField };\nexport type { MainField };\n", "/**\n * This hook doesn't use a context provider because we fetch directly from the server,\n * this sounds expensive but actually, it's really not. Because we have redux-toolkit-query\n * being a cache layer so if nothing invalidates the cache, we don't fetch again.\n */\n\nimport * as React from 'react';\n\nimport {\n  useNotification,\n  useAPIErrorHandler,\n  useQueryParams,\n  FormErrors,\n  getYupValidationErrors,\n  useForm,\n} from '@strapi/admin/strapi-admin';\nimport { useIntl } from 'react-intl';\nimport { useParams } from 'react-router-dom';\nimport { ValidationError } from 'yup';\n\nimport { SINGLE_TYPES } from '../constants/collections';\nimport { type AnyData, transformDocument } from '../pages/EditView/utils/data';\nimport { createDefaultForm } from '../pages/EditView/utils/forms';\nimport { useGetDocumentQuery } from '../services/documents';\nimport { buildValidParams } from '../utils/api';\nimport { createYupSchema } from '../utils/validation';\n\nimport { useContentTypeSchema, ComponentsDictionary } from './useContentTypeSchema';\nimport { useDocumentLayout } from './useDocumentLayout';\n\nimport type { FindOne } from '../../../shared/contracts/collection-types';\nimport type { ContentType } from '../../../shared/contracts/content-types';\nimport type { Modules } from '@strapi/types';\n\ninterface UseDocumentArgs {\n  collectionType: string;\n  model: string;\n  documentId?: string;\n  params?: object;\n}\n\ntype UseDocumentOpts = Parameters<typeof useGetDocumentQuery>[1];\n\ntype Document = FindOne.Response['data'];\n\ntype Schema = ContentType;\n\ntype UseDocument = (\n  args: UseDocumentArgs,\n  opts?: UseDocumentOpts\n) => {\n  /**\n   * These are the schemas of the components used in the content type, organised\n   * by their uid.\n   */\n  components: ComponentsDictionary;\n  document?: Document;\n  meta?: FindOne.Response['meta'];\n  isLoading: boolean;\n  /**\n   * This is the schema of the content type, it is not the same as the layout.\n   */\n  schema?: Schema;\n  schemas?: Schema[];\n  hasError?: boolean;\n  refetch: () => void;\n  validate: (document: Document) => null | FormErrors;\n  /**\n   * Get the document's title\n   */\n  getTitle: (mainField: string) => string;\n  /**\n   * Get the initial form values for the document\n   */\n  getInitialFormValues: (isCreatingDocument?: boolean) => AnyData | undefined;\n};\n\n/* -------------------------------------------------------------------------------------------------\n * useDocument\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @alpha\n * @public\n * @description Returns a document based on the model, collection type & id passed as arguments.\n * Also extracts its schema from the redux cache to be used for creating a validation schema.\n * @example\n * ```tsx\n * const { id, model, collectionType } = useParams<{ id: string; model: string; collectionType: string }>();\n *\n * if(!model || !collectionType) return null;\n *\n * const { document, isLoading, validate } = useDocument({ documentId: id, model, collectionType, params: { locale: 'en-GB' } })\n * const { update } = useDocumentActions()\n *\n * const onSubmit = async (document: Document) => {\n *  const errors = validate(document);\n *\n *  if(errors) {\n *      // handle errors\n *  }\n *\n *  await update({ collectionType, model, id }, document)\n * }\n * ```\n *\n * @see {@link https://contributor.strapi.io/docs/core/content-manager/hooks/use-document} for more information\n */\nconst useDocument: UseDocument = (args, opts) => {\n  const { toggleNotification } = useNotification();\n  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();\n  const { formatMessage } = useIntl();\n\n  const {\n    currentData: data,\n    isLoading: isLoadingDocument,\n    isFetching: isFetchingDocument,\n    error,\n    refetch,\n  } = useGetDocumentQuery(args, {\n    ...opts,\n    skip: (!args.documentId && args.collectionType !== SINGLE_TYPES) || opts?.skip,\n  });\n  const document = data?.data;\n  const meta = data?.meta;\n\n  const {\n    components,\n    schema,\n    schemas,\n    isLoading: isLoadingSchema,\n  } = useContentTypeSchema(args.model);\n  const isSingleType = schema?.kind === 'singleType';\n\n  const getTitle = (mainField: string) => {\n    // Always use mainField if it's not an id\n    if (mainField !== 'id' && document?.[mainField]) {\n      return document[mainField];\n    }\n\n    // When it's a singleType without a mainField, use the contentType displayName\n    if (isSingleType && schema?.info.displayName) {\n      return schema.info.displayName;\n    }\n\n    // Otherwise, use a fallback\n    return formatMessage({\n      id: 'content-manager.containers.untitled',\n      defaultMessage: 'Untitled',\n    });\n  };\n\n  React.useEffect(() => {\n    if (error) {\n      toggleNotification({\n        type: 'danger',\n        message: formatAPIError(error),\n      });\n    }\n  }, [toggleNotification, error, formatAPIError, args.collectionType]);\n\n  const validationSchema = React.useMemo(() => {\n    if (!schema) {\n      return null;\n    }\n\n    return createYupSchema(schema.attributes, components);\n  }, [schema, components]);\n\n  const validate = React.useCallback(\n    (document: Modules.Documents.AnyDocument): FormErrors | null => {\n      if (!validationSchema) {\n        throw new Error(\n          'There is no validation schema generated, this is likely due to the schema not being loaded yet.'\n        );\n      }\n\n      try {\n        validationSchema.validateSync(document, { abortEarly: false, strict: true });\n        return null;\n      } catch (error) {\n        if (error instanceof ValidationError) {\n          return getYupValidationErrors(error);\n        }\n\n        throw error;\n      }\n    },\n    [validationSchema]\n  );\n\n  /**\n   * Here we prepare the form for editing, we need to:\n   * - remove prohibited fields from the document (passwords | ADD YOURS WHEN THERES A NEW ONE)\n   * - swap out count objects on relations for empty arrays\n   * - set __temp_key__ on array objects for drag & drop\n   *\n   * We also prepare the form for new documents, so we need to:\n   * - set default values on fields\n   */\n  const getInitialFormValues = React.useCallback(\n    (isCreatingDocument: boolean = false) => {\n      if ((!document && !isCreatingDocument && !isSingleType) || !schema) {\n        return undefined;\n      }\n\n      /**\n       * Check that we have an ID so we know the\n       * document has been created in some way.\n       */\n      const form = document?.id ? document : createDefaultForm(schema, components);\n\n      return transformDocument(schema, components)(form);\n    },\n    [document, isSingleType, schema, components]\n  );\n\n  const isLoading = isLoadingDocument || isFetchingDocument || isLoadingSchema;\n  const hasError = !!error;\n\n  return {\n    components,\n    document,\n    meta,\n    isLoading,\n    hasError,\n    schema,\n    schemas,\n    validate,\n    getTitle,\n    getInitialFormValues,\n    refetch,\n  } satisfies ReturnType<UseDocument>;\n};\n\n/* -------------------------------------------------------------------------------------------------\n * useDoc\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal this hook uses the router to extract the model, collection type & id from the url.\n * therefore, it shouldn't be used outside of the content-manager because it won't work as intended.\n */\nconst useDoc = () => {\n  const { id, slug, collectionType, origin } = useParams<{\n    id: string;\n    origin: string;\n    slug: string;\n    collectionType: string;\n  }>();\n  const [{ query }] = useQueryParams();\n  const params = React.useMemo(() => buildValidParams(query), [query]);\n\n  if (!collectionType) {\n    throw new Error('Could not find collectionType in url params');\n  }\n\n  if (!slug) {\n    throw new Error('Could not find model in url params');\n  }\n\n  const document = useDocument(\n    { documentId: origin || id, model: slug, collectionType, params },\n    {\n      skip: id === 'create' || (!origin && !id && collectionType !== SINGLE_TYPES),\n    }\n  );\n\n  const returnId = origin || id === 'create' ? undefined : id;\n\n  return {\n    collectionType,\n    model: slug,\n    id: returnId,\n    ...document,\n  };\n};\n\n/**\n * @public\n * @experimental\n * Content manager context hooks for plugin development.\n * Make sure to use this hook inside the content manager.\n */\nconst useContentManagerContext = () => {\n  const {\n    collectionType,\n    model,\n    id,\n    components,\n    isLoading: isLoadingDoc,\n    schema,\n    schemas,\n  } = useDoc();\n\n  const layout = useDocumentLayout(model);\n\n  const form = useForm<unknown>('useContentManagerContext', (state) => state);\n\n  const isSingleType = collectionType === SINGLE_TYPES;\n  const slug = model;\n  const isCreatingEntry = id === 'create';\n\n  const {} = useContentTypeSchema();\n\n  const isLoading = isLoadingDoc || layout.isLoading;\n  const error = layout.error;\n\n  return {\n    error,\n    isLoading,\n\n    // Base metadata\n    model,\n    collectionType,\n    id,\n    slug,\n    isCreatingEntry,\n    isSingleType,\n    hasDraftAndPublish: schema?.options?.draftAndPublish ?? false,\n\n    // All schema infos\n    components,\n    contentType: schema,\n    contentTypes: schemas,\n\n    // Form state\n    form,\n\n    // layout infos\n    layout,\n  };\n};\n\nexport { useDocument, useDoc, useContentManagerContext };\nexport type { UseDocument, UseDocumentArgs, Document, Schema, ComponentsDictionary };\n", "import type { ComponentsDictionary, Document } from '../../../hooks/useDocument';\nimport type { Schema } from '@strapi/types';\n\ntype AnyData = Omit<Document, 'id'>;\n\n/* -------------------------------------------------------------------------------------------------\n * createDefaultForm\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * @internal Using the content-type schema & the components dictionary of the content-type,\n * creates a form with pre-filled default values. This is used when creating a new entry.\n */\nconst createDefaultForm = (\n  contentType: Schema.Schema,\n  components: ComponentsDictionary = {}\n): AnyData => {\n  const traverseSchema = (attributes: Schema.Schema['attributes']): AnyData => {\n    return Object.entries(attributes).reduce<AnyData>((acc, [key, attribute]) => {\n      if ('default' in attribute) {\n        acc[key] = attribute.default;\n      } else if (attribute.type === 'component' && attribute.required) {\n        const defaultComponentForm = traverseSchema(components[attribute.component].attributes);\n\n        if (attribute.repeatable) {\n          acc[key] = attribute.min ? [...Array(attribute.min).fill(defaultComponentForm)] : [];\n        } else {\n          acc[key] = defaultComponentForm;\n        }\n      } else if (attribute.type === 'dynamiczone' && attribute.required) {\n        acc[key] = [];\n      }\n\n      return acc;\n    }, {});\n  };\n\n  return traverseSchema(contentType.attributes);\n};\n\nexport { createDefaultForm };\n", "import clone from 'lodash/clone';\nimport toPath from 'lodash/toPath';\n\n/**\n * Deeply get a value from an object via its path.\n */\nexport function getIn(obj: any, key: string | string[], def?: any, pathStartIndex: number = 0) {\n  const path = toPath(key);\n  while (obj && pathStartIndex < path.length) {\n    obj = obj[path[pathStartIndex++]];\n  }\n\n  // check if path is not in the end\n  if (pathStartIndex !== path.length && !obj) {\n    return def;\n  }\n\n  return obj === undefined ? def : obj;\n}\n\n/** @internal is the given object an Object? */\nexport const isObject = (obj: any): obj is object =>\n  obj !== null && typeof obj === 'object' && !Array.isArray(obj);\n\n/** @internal is the given object an integer? */\nexport const isInteger = (obj: any): boolean => String(Math.floor(Number(obj))) === obj;\n\n/**\n * Deeply set a value from in object via its path. If the value at `path`\n * has changed, return a shallow copy of obj with `value` set at `path`.\n * If `value` has not changed, return the original `obj`.\n *\n * Existing objects / arrays along `path` are also shallow copied. Sibling\n * objects along path retain the same internal js reference. Since new\n * objects / arrays are only created along `path`, we can test if anything\n * changed in a nested structure by comparing the object's reference in\n * the old and new object, similar to how russian doll cache invalidation\n * works.\n *\n * In earlier versions of this function, which used cloneDeep, there were\n * issues whereby settings a nested value would mutate the parent\n * instead of creating a new object. `clone` avoids that bug making a\n * shallow copy of the objects along the update path\n * so no object is mutated in place.\n *\n * Before changing this function, please read through the following\n * discussions.\n *\n * @see https://github.com/developit/linkstate\n * @see https://github.com/jaredpalmer/formik/pull/123\n */\nexport function setIn(obj: any, path: string, value: any): any {\n  const res: any = clone(obj); // this keeps inheritance when obj is a class\n  let resVal: any = res;\n  let i = 0;\n  const pathArray = toPath(path);\n\n  for (; i < pathArray.length - 1; i++) {\n    const currentPath: string = pathArray[i];\n    const currentObj: any = getIn(obj, pathArray.slice(0, i + 1));\n\n    if (currentObj && (isObject(currentObj) || Array.isArray(currentObj))) {\n      resVal = resVal[currentPath] = clone(currentObj);\n    } else {\n      const nextPath: string = pathArray[i + 1];\n      resVal = resVal[currentPath] = isInteger(nextPath) && Number(nextPath) >= 0 ? [] : {};\n    }\n  }\n\n  // Return original object if new value is the same as current\n  if ((i === 0 ? obj : resVal)[pathArray[i]] === value) {\n    return obj;\n  }\n\n  if (value === undefined) {\n    delete resVal[pathArray[i]];\n  } else {\n    resVal[pathArray[i]] = value;\n  }\n\n  // If the path array has a single element, the loop did not run.\n  // Deleting on `resVal` had no effect in this scenario, so we delete on the result instead.\n  if (i === 0 && value === undefined) {\n    delete res[pathArray[i]];\n  }\n\n  return res;\n}\n"],
  "mappings": "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",
  "names": ["_a", "pipe", "import_pipe", "attributes", "create", "pipe", "contentType", "components", "attributes", "_a", "React", "React", "document", "error", "toPath", "clone"]
}
