import {
  intervalToDuration
} from "./chunk-QP5S5OPY.js";
import {
  errorsTrads
} from "./chunk-PM2LZIAE.js";
import {
  create4 as create,
  create6 as create2
} from "./chunk-H5MBP66A.js";
import {
  require_lib
} from "./chunk-ZOFH3G6M.js";
import {
  __toESM
} from "./chunk-X6GFWOGJ.js";

// ../packages/core/upload/package.json
var package_default = {
  name: "@strapi/upload",
  version: "5.23.4",
  description: "Makes it easy to upload images and files to your Strapi Application.",
  license: "SEE LICENSE IN LICENSE",
  author: {
    name: "Strapi Solutions SAS",
    email: "hi@strapi.io",
    url: "https://strapi.io"
  },
  maintainers: [
    {
      name: "Strapi Solutions SAS",
      email: "hi@strapi.io",
      url: "https://strapi.io"
    }
  ],
  exports: {
    "./strapi-admin": {
      types: "./dist/admin/src/index.d.ts",
      source: "./admin/src/index.ts",
      import: "./dist/admin/index.mjs",
      require: "./dist/admin/index.js",
      default: "./dist/admin/index.js"
    },
    "./_internal/shared": {
      types: "./dist/shared/index.d.ts",
      source: "./shared/index.ts",
      import: "./dist/shared/index.mjs",
      require: "./dist/shared/index.js",
      default: "./dist/shared/index.js"
    },
    "./strapi-server": {
      types: "./dist/server/src/index.d.ts",
      source: "./server/src/index.ts",
      import: "./dist/server/index.mjs",
      require: "./dist/server/index.js",
      default: "./dist/server/index.js"
    },
    "./package.json": "./package.json"
  },
  files: [
    "dist/",
    "strapi-server.js"
  ],
  scripts: {
    build: "run -T npm-run-all clean --parallel build:code build:types",
    "build:code": "run -T rollup -c",
    "build:types": "run -T run-p build:types:server build:types:admin",
    "build:types:server": "run -T tsc -p server/tsconfig.build.json --emitDeclarationOnly",
    "build:types:admin": "run -T tsc -p admin/tsconfig.build.json --emitDeclarationOnly",
    clean: "run -T rimraf dist",
    lint: "run -T eslint .",
    "test:front": "run -T cross-env IS_EE=true jest --config ./jest.config.front.js",
    "test:unit": "run -T jest",
    "test:ts:back": "run -T tsc --noEmit -p server/tsconfig.json",
    "test:ts:front": "run -T tsc -p admin/tsconfig.json",
    "test:front:watch": "run -T cross-env IS_EE=true jest --config ./jest.config.front.js --watch",
    "test:unit:watch": "run -T jest --watch",
    watch: "run -T rollup -c -w"
  },
  dependencies: {
    "@mux/mux-player-react": "3.1.0",
    "@reduxjs/toolkit": "1.9.7",
    "@strapi/design-system": "2.0.0-rc.29",
    "@strapi/icons": "2.0.0-rc.29",
    "@strapi/provider-upload-local": "5.23.4",
    "@strapi/utils": "5.23.4",
    "byte-size": "8.1.1",
    cropperjs: "1.6.1",
    "date-fns": "2.30.0",
    formik: "2.4.5",
    "fs-extra": "11.2.0",
    immer: "9.0.21",
    "koa-range": "0.3.0",
    "koa-static": "5.0.0",
    lodash: "4.17.21",
    "mime-types": "2.1.35",
    "prop-types": "^15.8.1",
    qs: "6.11.1",
    "react-dnd": "16.0.1",
    "react-intl": "6.6.2",
    "react-query": "3.39.3",
    "react-redux": "8.1.3",
    "react-select": "5.8.0",
    sharp: "0.33.5",
    yup: "0.32.9",
    zod: "3.25.67"
  },
  devDependencies: {
    "@strapi/admin": "5.23.4",
    "@strapi/types": "5.23.4",
    "@testing-library/dom": "10.1.0",
    "@testing-library/react": "15.0.7",
    "@testing-library/user-event": "14.5.2",
    "@types/byte-size": "8.1.2",
    "@types/fs-extra": "11.0.4",
    "@types/koa": "2.13.4",
    "@types/koa-range": "0.3.5",
    "@types/koa-static": "4.0.2",
    formidable: "3.5.4",
    koa: "2.16.1",
    "koa-body": "6.0.1",
    msw: "1.3.0",
    react: "18.3.1",
    "react-dom": "18.3.1",
    "react-router-dom": "6.22.3",
    "styled-components": "6.1.8"
  },
  peerDependencies: {
    "@strapi/admin": "^5.0.0",
    react: "^17.0.0 || ^18.0.0",
    "react-dom": "^17.0.0 || ^18.0.0",
    "react-router-dom": "^6.0.0",
    "styled-components": "^6.0.0"
  },
  engines: {
    node: ">=18.0.0 <=22.x.x",
    npm: ">=6.0.0"
  },
  strapi: {
    displayName: "Media Library",
    name: "upload",
    description: "Media file management.",
    required: true,
    kind: "plugin"
  }
};

// ../packages/core/upload/admin/src/pluginId.ts
var pluginId = package_default.name.replace(/^@strapi\//i, "");

// ../packages/core/upload/admin/src/utils/getTrad.ts
var getTrad = (id) => `${pluginId}.${id}`;

// ../packages/core/upload/admin/src/utils/appendSearchParamsToUrl.ts
var appendSearchParamsToUrl = ({ url, params }) => {
  if (url === void 0 || typeof params !== "object") {
    return url;
  }
  const urlObj = new URL(url, window.strapi.backendURL);
  Object.entries(params).forEach(([key, value]) => {
    if (value !== void 0 && value !== null) {
      urlObj.searchParams.append(key, value);
    }
  });
  return urlObj.toString();
};

// ../packages/core/upload/admin/src/utils/containsAssetFilter.ts
var containsMimeTypeFilter = (query) => {
  var _a;
  const filters = (_a = query == null ? void 0 : query.filters) == null ? void 0 : _a.$and;
  if (!filters) {
    return false;
  }
  const result = filters.find((filter) => {
    return Object.keys(filter).includes("mime");
  });
  return !!result;
};
var containsAssetFilter = (query) => {
  return containsMimeTypeFilter(query);
};

// ../packages/core/upload/admin/src/utils/prefixFileUrlWithBackendUrl.ts
var prefixFileUrlWithBackendUrl = (fileURL) => {
  return !!fileURL && fileURL.startsWith("/") ? `${window.strapi.backendURL}${fileURL}` : fileURL;
};

// ../packages/core/upload/admin/src/utils/createAssetUrl.ts
var createAssetUrl = (asset, forThumbnail = true) => {
  var _a, _b;
  if (asset.isLocal) {
    return asset.url;
  }
  const assetUrl = forThumbnail ? ((_b = (_a = asset == null ? void 0 : asset.formats) == null ? void 0 : _a.thumbnail) == null ? void 0 : _b.url) || asset.url : asset.url;
  return prefixFileUrlWithBackendUrl(assetUrl);
};

// ../packages/core/upload/admin/src/utils/displayedFilters.ts
var displayedFilters = [
  {
    name: "createdAt",
    fieldSchema: {
      type: "date"
    },
    metadatas: { label: "createdAt" }
  },
  {
    name: "updatedAt",
    fieldSchema: {
      type: "date"
    },
    metadatas: { label: "updatedAt" }
  },
  {
    name: "mime",
    fieldSchema: {
      type: "enumeration",
      options: [
        { label: "audio", value: "audio" },
        { label: "file", value: "file" },
        { label: "image", value: "image" },
        { label: "video", value: "video" }
      ]
    },
    metadatas: { label: "type" }
  }
];

// ../packages/core/upload/admin/src/utils/downloadFile.ts
var downloadFile = async (url, fileName) => {
  const fileBlob = await fetch(url).then((res) => res.blob());
  const urlDownload = window.URL.createObjectURL(fileBlob);
  const link = document.createElement("a");
  link.href = urlDownload;
  link.setAttribute("download", fileName);
  link.click();
};

// ../packages/core/upload/admin/src/utils/findRecursiveFolderByValue.ts
function findRecursiveFolderByValue(data, value) {
  let result;
  function iter(a) {
    if (a.value === value) {
      result = a;
      return true;
    }
    return Array.isArray(a.children) && a.children.some(iter);
  }
  data.some(iter);
  return result;
}

// ../node_modules/byte-size/index.js
var defaultOptions = {};
var _options = /* @__PURE__ */ new WeakMap();
var referenceTables = {
  metric: [
    { from: 0, to: 1e3, unit: "B", long: "bytes" },
    { from: 1e3, to: 1e6, unit: "kB", long: "kilobytes" },
    { from: 1e6, to: 1e9, unit: "MB", long: "megabytes" },
    { from: 1e9, to: 1e12, unit: "GB", long: "gigabytes" },
    { from: 1e12, to: 1e15, unit: "TB", long: "terabytes" },
    { from: 1e15, to: 1e18, unit: "PB", long: "petabytes" },
    { from: 1e18, to: 1e21, unit: "EB", long: "exabytes" },
    { from: 1e21, to: 1e24, unit: "ZB", long: "zettabytes" },
    { from: 1e24, to: 1e27, unit: "YB", long: "yottabytes" }
  ],
  metric_octet: [
    { from: 0, to: 1e3, unit: "o", long: "octets" },
    { from: 1e3, to: 1e6, unit: "ko", long: "kilooctets" },
    { from: 1e6, to: 1e9, unit: "Mo", long: "megaoctets" },
    { from: 1e9, to: 1e12, unit: "Go", long: "gigaoctets" },
    { from: 1e12, to: 1e15, unit: "To", long: "teraoctets" },
    { from: 1e15, to: 1e18, unit: "Po", long: "petaoctets" },
    { from: 1e18, to: 1e21, unit: "Eo", long: "exaoctets" },
    { from: 1e21, to: 1e24, unit: "Zo", long: "zettaoctets" },
    { from: 1e24, to: 1e27, unit: "Yo", long: "yottaoctets" }
  ],
  iec: [
    { from: 0, to: Math.pow(1024, 1), unit: "B", long: "bytes" },
    { from: Math.pow(1024, 1), to: Math.pow(1024, 2), unit: "KiB", long: "kibibytes" },
    { from: Math.pow(1024, 2), to: Math.pow(1024, 3), unit: "MiB", long: "mebibytes" },
    { from: Math.pow(1024, 3), to: Math.pow(1024, 4), unit: "GiB", long: "gibibytes" },
    { from: Math.pow(1024, 4), to: Math.pow(1024, 5), unit: "TiB", long: "tebibytes" },
    { from: Math.pow(1024, 5), to: Math.pow(1024, 6), unit: "PiB", long: "pebibytes" },
    { from: Math.pow(1024, 6), to: Math.pow(1024, 7), unit: "EiB", long: "exbibytes" },
    { from: Math.pow(1024, 7), to: Math.pow(1024, 8), unit: "ZiB", long: "zebibytes" },
    { from: Math.pow(1024, 8), to: Math.pow(1024, 9), unit: "YiB", long: "yobibytes" }
  ],
  iec_octet: [
    { from: 0, to: Math.pow(1024, 1), unit: "o", long: "octets" },
    { from: Math.pow(1024, 1), to: Math.pow(1024, 2), unit: "Kio", long: "kibioctets" },
    { from: Math.pow(1024, 2), to: Math.pow(1024, 3), unit: "Mio", long: "mebioctets" },
    { from: Math.pow(1024, 3), to: Math.pow(1024, 4), unit: "Gio", long: "gibioctets" },
    { from: Math.pow(1024, 4), to: Math.pow(1024, 5), unit: "Tio", long: "tebioctets" },
    { from: Math.pow(1024, 5), to: Math.pow(1024, 6), unit: "Pio", long: "pebioctets" },
    { from: Math.pow(1024, 6), to: Math.pow(1024, 7), unit: "Eio", long: "exbioctets" },
    { from: Math.pow(1024, 7), to: Math.pow(1024, 8), unit: "Zio", long: "zebioctets" },
    { from: Math.pow(1024, 8), to: Math.pow(1024, 9), unit: "Yio", long: "yobioctets" }
  ]
};
var ByteSize = class {
  constructor(bytes, options) {
    options = Object.assign({
      units: "metric",
      precision: 1,
      locale: void 0
      // Default to the user's system locale
    }, defaultOptions, options);
    _options.set(this, options);
    Object.assign(referenceTables, options.customUnits);
    const prefix = bytes < 0 ? "-" : "";
    bytes = Math.abs(bytes);
    const table = referenceTables[options.units];
    if (table) {
      const units = table.find((u) => bytes >= u.from && bytes < u.to);
      if (units) {
        const defaultFormat = new Intl.NumberFormat(options.locale, {
          style: "decimal",
          minimumFractionDigits: options.precision,
          maximumFractionDigits: options.precision
        });
        const value = units.from === 0 ? prefix + bytes : prefix + defaultFormat.format(bytes / units.from);
        this.value = value;
        this.unit = units.unit;
        this.long = units.long;
      } else {
        this.value = prefix + bytes;
        this.unit = "";
        this.long = "";
      }
    } else {
      throw new Error(`Invalid units specified: ${options.units}`);
    }
  }
  toString() {
    const options = _options.get(this);
    return options.toStringFn ? options.toStringFn.bind(this)() : `${this.value} ${this.unit}`;
  }
};
function byteSize(bytes, options) {
  return new ByteSize(bytes, options);
}
byteSize.defaultOptions = function(options) {
  defaultOptions = options;
};
var byte_size_default = byteSize;

// ../packages/core/upload/admin/src/utils/formatBytes.ts
function formatBytes(receivedBytes, decimals = 0) {
  const realBytes = typeof receivedBytes === "string" ? Number(receivedBytes) : receivedBytes;
  const { value, unit } = byte_size_default(realBytes * 1e3, { precision: decimals });
  if (!unit) {
    return "0B";
  }
  return `${value}${unit.toUpperCase()}`;
}

// ../packages/core/upload/admin/src/utils/formatDuration.ts
var zeroPad = (num) => String(num).padStart(2, "0");
var formatDuration = (durationInSecond) => {
  const duration = intervalToDuration({ start: 0, end: durationInSecond * 1e3 });
  return `${zeroPad(duration.hours)}:${zeroPad(duration.minutes)}:${zeroPad(duration.seconds)}`;
};

// ../packages/core/upload/admin/src/utils/toSingularTypes.ts
var toSingularTypes = (types) => {
  if (!types) {
    return [];
  }
  return types.map((type) => type.substring(0, type.length - 1));
};

// ../packages/core/upload/admin/src/utils/getAllowedFiles.ts
var getAllowedFiles = (pluralTypes, files) => {
  if (!pluralTypes) {
    return files;
  }
  const singularTypes = toSingularTypes(pluralTypes);
  const allowedFiles = files.filter((file) => {
    var _a;
    const fileType = (_a = file == null ? void 0 : file.mime) == null ? void 0 : _a.split("/")[0];
    if (!fileType) {
      return false;
    }
    if (singularTypes.includes("file") && !["video", "image", "audio"].includes(fileType)) {
      return true;
    }
    return singularTypes.includes(fileType);
  });
  return allowedFiles;
};

// ../packages/core/upload/admin/src/utils/normalizeAPIError.ts
function getPrefixedId(message, callback) {
  const prefixedMessage = `apiError.${message}`;
  if (typeof callback === "function") {
    return callback(prefixedMessage);
  }
  return prefixedMessage;
}
function normalizeError(error, { name, intlMessagePrefixCallback }) {
  const { message } = error;
  const normalizedError = {
    id: getPrefixedId(message, intlMessagePrefixCallback),
    defaultMessage: message,
    name: error.name ?? name,
    values: {}
  };
  if ("path" in error) {
    normalizedError.values = { path: error.path.join(".") };
  }
  return normalizedError;
}
var validateErrorIsYupValidationError = (err) => typeof err.details === "object" && err.details !== null && "errors" in err.details;
function normalizeAPIError(apiError, intlMessagePrefixCallback) {
  var _a;
  const error = (_a = apiError.response) == null ? void 0 : _a.data.error;
  if (error) {
    if (validateErrorIsYupValidationError(error)) {
      return {
        name: error.name,
        message: (error == null ? void 0 : error.message) || null,
        errors: error.details.errors.map(
          (err) => normalizeError(err, { name: error.name, intlMessagePrefixCallback })
        )
      };
    }
    return normalizeError(error, { intlMessagePrefixCallback });
  }
  return null;
}

// ../packages/core/upload/admin/src/utils/getAPIInnerErrors.ts
function getAPIInnerErrors(error, { getTrad: getTrad2 }) {
  const normalizedError = normalizeAPIError(error, getTrad2);
  if (normalizedError && "errors" in normalizedError) {
    return normalizedError.errors.reduce((acc, error2) => {
      if ("path" in error2.values) {
        acc[error2.values.path] = {
          id: error2.id,
          defaultMessage: error2.defaultMessage
        };
      }
      return acc;
    }, {});
  }
  return normalizedError == null ? void 0 : normalizedError.defaultMessage;
}

// ../packages/core/upload/admin/src/utils/getBreadcrumbDataCM.ts
var getBreadcrumbDataCM = (folder) => {
  var _a;
  const data = [
    {
      id: null,
      label: { id: getTrad("plugin.name"), defaultMessage: "Media Library" }
    }
  ];
  if ((_a = folder == null ? void 0 : folder.parent) == null ? void 0 : _a.parent) {
    data.push([]);
  }
  if (folder == null ? void 0 : folder.parent) {
    data.push({
      id: folder.parent.id,
      label: folder.parent.name,
      path: folder.parent.path
    });
  }
  if (folder) {
    data.push({
      id: folder.id,
      label: folder.name,
      path: folder.path
    });
  }
  return data;
};

// ../packages/core/upload/admin/src/utils/getFolderURL.ts
var import_qs = __toESM(require_lib());
var getFolderURL = (pathname, currentQuery, { folder, folderPath } = {}) => {
  const { _q, ...queryParamsWithoutQ } = currentQuery;
  const queryParamsString = (0, import_qs.stringify)(
    {
      ...queryParamsWithoutQ,
      folder,
      folderPath
    },
    { encode: false }
  );
  return `${pathname}${queryParamsString ? `?${queryParamsString}` : ""}`;
};

// ../packages/core/upload/admin/src/utils/getBreadcrumbDataML.ts
var getBreadcrumbDataML = (folder, { pathname, query }) => {
  var _a, _b;
  const data = [
    {
      id: null,
      label: { id: getTrad("plugin.name"), defaultMessage: "Media Library" },
      href: folder ? getFolderURL(pathname, query || {}) : void 0
    }
  ];
  if ((folder == null ? void 0 : folder.parent) && typeof (folder == null ? void 0 : folder.parent) !== "number" && ((_a = folder == null ? void 0 : folder.parent) == null ? void 0 : _a.parent)) {
    data.push([]);
  }
  if ((folder == null ? void 0 : folder.parent) && typeof folder.parent !== "number") {
    data.push({
      id: folder.parent.id,
      label: folder.parent.name,
      href: getFolderURL(pathname, query || {}, {
        folder: (_b = folder.parent.id) == null ? void 0 : _b.toString(),
        folderPath: folder.parent.path
      })
    });
  }
  if (folder) {
    data.push({
      id: folder.id,
      label: folder.name
    });
  }
  return data;
};

// ../packages/core/upload/admin/src/utils/getFileExtension.ts
var getFileExtension = (ext) => ext && ext[0] === "." ? ext.substring(1) : ext;

// ../packages/core/upload/admin/src/components/SelectTree/utils/flattenTree.ts
function flattenTree(tree, parent = null, depth = 0) {
  return tree.flatMap(
    (item) => item.children ? [{ ...item, parent: parent == null ? void 0 : parent.value, depth }, ...flattenTree(item.children, item, depth + 1)] : { ...item, depth, parent: parent == null ? void 0 : parent.value }
  );
}

// ../packages/core/upload/admin/src/utils/getFolderParents.ts
var getFolderParents = (folders, currentFolderId) => {
  const parents = [];
  const flatFolders = flattenTree(folders);
  const currentFolder = flatFolders.find((folder) => folder.value === currentFolderId);
  if (!currentFolder) {
    return [];
  }
  let { parent } = currentFolder;
  while (parent !== void 0) {
    const parentToStore = flatFolders.find(({ value }) => value === parent);
    parents.push({ id: parentToStore == null ? void 0 : parentToStore.value, label: parentToStore == null ? void 0 : parentToStore.label });
    parent = parentToStore == null ? void 0 : parentToStore.parent;
  }
  return parents.reverse();
};

// ../packages/core/upload/admin/src/utils/moveElement.ts
var move = (array, oldIndex, newIndex) => {
  if (newIndex >= array.length) {
    newIndex = array.length - 1;
  }
  array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);
  return array;
};
var moveElement = (array, index, offset) => {
  const newIndex = index + offset;
  return move(array, index, newIndex);
};

// ../packages/core/upload/admin/src/utils/prefixPluginTranslations.ts
var prefixPluginTranslations = (trad, pluginId2) => {
  if (!pluginId2) {
    throw new TypeError("pluginId can't be empty");
  }
  return Object.keys(trad).reduce((acc, current) => {
    acc[`${pluginId2}.${current}`] = trad[current];
    return acc;
  }, {});
};

// ../packages/core/upload/admin/src/constants.ts
var PERMISSIONS = {
  // This permission regards the main component (App) and is used to tell
  // If the plugin link should be displayed in the menu
  // And also if the plugin is accessible. This use case is found when a user types the url of the
  // plugin directly in the browser
  main: [
    { action: "plugin::upload.read", subject: null },
    {
      action: "plugin::upload.assets.create",
      subject: null
    },
    {
      action: "plugin::upload.assets.update",
      subject: null
    }
  ],
  copyLink: [
    {
      action: "plugin::upload.assets.copy-link",
      subject: null
    }
  ],
  create: [
    {
      action: "plugin::upload.assets.create",
      subject: null
    }
  ],
  download: [
    {
      action: "plugin::upload.assets.download",
      subject: null
    }
  ],
  read: [{ action: "plugin::upload.read", subject: null }],
  configureView: [{ action: "plugin::upload.configure-view", subject: null }],
  settings: [{ action: "plugin::upload.settings.read", subject: null }],
  update: [{ action: "plugin::upload.assets.update", subject: null, fields: null }]
};
var tableHeaders = [
  {
    name: "preview",
    key: "preview",
    metadatas: {
      label: { id: getTrad("list.table.header.preview"), defaultMessage: "preview" },
      isSortable: false
    },
    type: "image"
  },
  {
    name: "name",
    key: "name",
    metadatas: {
      label: { id: getTrad("list.table.header.name"), defaultMessage: "name" },
      isSortable: true
    },
    type: "text"
  },
  {
    name: "ext",
    key: "extension",
    metadatas: {
      label: { id: getTrad("list.table.header.ext"), defaultMessage: "extension" },
      isSortable: false
    },
    type: "ext"
  },
  {
    name: "size",
    key: "size",
    metadatas: {
      label: { id: getTrad("list.table.header.size"), defaultMessage: "size" },
      isSortable: false
    },
    type: "size"
  },
  {
    name: "createdAt",
    key: "createdAt",
    metadatas: {
      label: { id: getTrad("list.table.header.createdAt"), defaultMessage: "created" },
      isSortable: true
    },
    type: "date"
  },
  {
    name: "updatedAt",
    key: "updatedAt",
    metadatas: {
      label: { id: getTrad("list.table.header.updatedAt"), defaultMessage: "last update" },
      isSortable: true
    },
    type: "date"
  }
];
var sortOptions = [
  { key: "sort.created_at_desc", value: "createdAt:DESC" },
  { key: "sort.created_at_asc", value: "createdAt:ASC" },
  { key: "sort.name_asc", value: "name:ASC" },
  { key: "sort.name_desc", value: "name:DESC" },
  { key: "sort.updated_at_desc", value: "updatedAt:DESC" },
  { key: "sort.updated_at_asc", value: "updatedAt:ASC" }
];
var pageSizes = [10, 20, 50, 100];
var localStorageKeys = {
  modalView: `STRAPI_UPLOAD_MODAL_VIEW`,
  view: `STRAPI_UPLOAD_LIBRARY_VIEW`
};
var viewOptions = {
  GRID: 0,
  LIST: 1
};

// ../packages/core/upload/admin/src/utils/typeFromMime.ts
var typeFromMime = (mime) => {
  if (mime.includes("image" /* Image */)) {
    return "image" /* Image */;
  }
  if (mime.includes("video" /* Video */)) {
    return "video" /* Video */;
  }
  if (mime.includes("audio" /* Audio */)) {
    return "audio" /* Audio */;
  }
  return "doc" /* Document */;
};

// ../packages/core/upload/admin/src/utils/rawFileToAsset.ts
var rawFileToAsset = (rawFile, assetSource) => {
  return {
    size: rawFile.size / 1e3,
    createdAt: new Date(rawFile.lastModified).toISOString(),
    name: rawFile.name,
    source: assetSource,
    type: typeFromMime(rawFile.type),
    url: URL.createObjectURL(rawFile),
    ext: rawFile.name.split(".").pop(),
    mime: rawFile.type,
    rawFile,
    isLocal: true
  };
};

// ../packages/core/upload/admin/src/utils/urlsToAssets.ts
function getFilenameFromURL(url) {
  return new URL(url).pathname.split("/").pop();
}
var urlsToAssets = async (urls) => {
  const assetPromises = urls.map(
    (url) => fetch(url).then(async (res) => {
      const blob = await res.blob();
      const loadedFile = new File([blob], getFilenameFromURL(res.url), {
        type: res.headers.get("content-type") || void 0
      });
      return {
        name: loadedFile.name,
        url: res.url,
        mime: res.headers.get("content-type"),
        rawFile: loadedFile
      };
    })
  );
  const assetsResults = await Promise.all(assetPromises);
  const assets = assetsResults.map((fullFilledAsset) => ({
    source: "url" /* Url */,
    name: fullFilledAsset.name,
    type: typeFromMime(fullFilledAsset.mime),
    url: fullFilledAsset.url,
    ext: fullFilledAsset.url.split(".").pop(),
    mime: fullFilledAsset.mime ? fullFilledAsset.mime : void 0,
    rawFile: fullFilledAsset.rawFile
  }));
  return assets;
};

// ../packages/core/upload/admin/src/utils/urlYupSchema.ts
var urlSchema = create2().shape({
  urls: create().test({
    name: "isUrlValid",
    // eslint-disable-next-line no-template-curly-in-string
    message: "${path}",
    test(values = "") {
      const urls = values.split(/\r?\n/);
      if (urls.length === 0) {
        return this.createError({
          path: this.path,
          message: errorsTrads.min.id
        });
      }
      if (urls.length > 20) {
        return this.createError({
          path: this.path,
          message: errorsTrads.max.id
        });
      }
      const filtered = urls.filter((val) => {
        try {
          new URL(val);
          return false;
        } catch (err) {
          return true;
        }
      });
      const filteredLength = filtered.length;
      if (filteredLength === 0) {
        return true;
      }
      const errorMessage = filteredLength > 1 ? "form.upload-url.error.url.invalids" : "form.upload-url.error.url.invalid";
      return this.createError({
        path: this.path,
        message: getTrad(errorMessage),
        params: { number: filtered.length }
      });
    }
  })
});

export {
  package_default,
  pluginId,
  appendSearchParamsToUrl,
  containsAssetFilter,
  prefixFileUrlWithBackendUrl,
  createAssetUrl,
  displayedFilters,
  downloadFile,
  findRecursiveFolderByValue,
  formatBytes,
  formatDuration,
  toSingularTypes,
  getAllowedFiles,
  normalizeAPIError,
  getAPIInnerErrors,
  getTrad,
  getBreadcrumbDataCM,
  getFolderURL,
  getBreadcrumbDataML,
  getFileExtension,
  flattenTree,
  getFolderParents,
  moveElement,
  prefixPluginTranslations,
  rawFileToAsset,
  urlsToAssets,
  urlSchema,
  PERMISSIONS,
  tableHeaders,
  sortOptions,
  pageSizes,
  localStorageKeys,
  viewOptions
};
//# sourceMappingURL=chunk-T6YJK32F.js.map
