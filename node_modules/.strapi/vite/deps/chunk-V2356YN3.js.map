{
  "version": 3,
  "sources": ["../../../../../packages/core/admin/admin/src/utils/users.ts"],
  "sourcesContent": ["import type { User } from '../features/Auth';\n\n/* -------------------------------------------------------------------------------------------------\n * getDisplayName\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Retrieves the display name of an admin panel user\n */\nconst getDisplayName = ({ firstname, lastname, username, email }: Partial<User> = {}): string => {\n  if (username) {\n    return username;\n  }\n\n  // firstname is not required if the user is created with a username\n  if (firstname) {\n    return `${firstname} ${lastname ?? ''}`.trim();\n  }\n\n  return email ?? '';\n};\n\n/* -------------------------------------------------------------------------------------------------\n * getInitials\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Retrieves the initials of the user (based on their firstname / lastname or their display name)\n */\nconst getInitials = (user: Partial<User> = {}): string => {\n  return user?.firstname && user?.lastname\n    ? `${user.firstname.substring(0, 1)}${user.lastname.substring(0, 1)}`\n    : getDisplayName(user)\n        .split(' ')\n        .map((name) => name.substring(0, 1))\n        .join('')\n        .substring(0, 1)\n        .toUpperCase();\n};\n\n/* -------------------------------------------------------------------------------------------------\n * hashAdminUserEmail\n * -----------------------------------------------------------------------------------------------*/\n\nconst hashAdminUserEmail = async (payload?: User) => {\n  if (!payload || !payload.email) {\n    return null;\n  }\n\n  try {\n    return await digestMessage(payload.email);\n  } catch (error) {\n    return null;\n  }\n};\n\nconst bufferToHex = (buffer: ArrayBuffer) => {\n  return [...new Uint8Array(buffer)].map((b) => b.toString(16).padStart(2, '0')).join('');\n};\nconst digestMessage = async (message: string) => {\n  const msgUint8 = new TextEncoder().encode(message);\n  const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);\n\n  return bufferToHex(hashBuffer);\n};\n\nexport { getDisplayName, getInitials, hashAdminUserEmail };\n"],
  "mappings": ";AASA,IAAM,iBAAiB,CAAC,EAAE,WAAW,UAAU,UAAU,MAAM,IAAmB,CAAC,MAAc;AAC/F,MAAI,UAAU;AACZ,WAAO;AAAA,EACT;AAGA,MAAI,WAAW;AACb,WAAO,GAAG,SAAS,IAAI,YAAY,EAAE,GAAG,KAAK;AAAA,EAC/C;AAEA,SAAO,SAAS;AAClB;AASA,IAAM,cAAc,CAAC,OAAsB,CAAC,MAAc;AACxD,UAAO,6BAAM,eAAa,6BAAM,YAC5B,GAAG,KAAK,UAAU,UAAU,GAAG,CAAC,CAAC,GAAG,KAAK,SAAS,UAAU,GAAG,CAAC,CAAC,KACjE,eAAe,IAAI,EAChB,MAAM,GAAG,EACT,IAAI,CAAC,SAAS,KAAK,UAAU,GAAG,CAAC,CAAC,EAClC,KAAK,EAAE,EACP,UAAU,GAAG,CAAC,EACd,YAAY;AACrB;AAMA,IAAM,qBAAqB,OAAO,YAAmB;AACnD,MAAI,CAAC,WAAW,CAAC,QAAQ,OAAO;AAC9B,WAAO;AAAA,EACT;AAEA,MAAI;AACF,WAAO,MAAM,cAAc,QAAQ,KAAK;AAAA,EAC1C,SAAS,OAAO;AACd,WAAO;AAAA,EACT;AACF;AAEA,IAAM,cAAc,CAAC,WAAwB;AAC3C,SAAO,CAAC,GAAG,IAAI,WAAW,MAAM,CAAC,EAAE,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EAAE,KAAK,EAAE;AACxF;AACA,IAAM,gBAAgB,OAAO,YAAoB;AAC/C,QAAM,WAAW,IAAI,YAAY,EAAE,OAAO,OAAO;AACjD,QAAM,aAAa,MAAM,OAAO,OAAO,OAAO,WAAW,QAAQ;AAEjE,SAAO,YAAY,UAAU;AAC/B;",
  "names": []
}
